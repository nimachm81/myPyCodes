## FourierND.py
## N-Dimensional Fourier Analysis


__all__ = ["PDEFourierSeriesND"]


import sympy
from sympy import zeros, abc, Matrix, eye, Symbol, Sum, I, oo, Function,\
             expand, Mul, Add, Tuple, Integer, lambdify, KroneckerDelta


import numpy as np
from scipy.sparse import csr_matrix, coo_matrix
from scipy import linalg, fftpack
#from cmath import *
import cmath

from Electromagnetics.SymExprTree import *


class PDEFourierSeriesND:
    """ N-Dimensional Fourier series analysis of differential equations
    """
    def __init__(self, expr, vars, x_str='x', X_str='X', n_str='n', n_dim=1, 
            mark='\\tilde', harmonicMul=None):
        assert n_dim>=0
        self.expr = expr
        self.vars = vars
        self.x_str = x_str
        self.n_str = n_str
        self.N_Dim = n_dim
        self.harmonicMul = harmonicMul
        
        self.xs = [None]*self.N_Dim
        self.Xs = [None]*self.N_Dim
        self.ns = [None]*self.N_Dim
        self.dummys_str = ['m', 'p', 's']

        for i in range(self.N_Dim):
            self.xs[i] = Symbol(x_str + '_' + str(i))
            self.Xs[i] = Symbol(X_str + '_' + str(i))
            self.ns[i] = Symbol(n_str + '_' + str(i))
        
        self.harmonic = Integer(1)
        
        for i in range(self.N_Dim):
            self.harmonic = self.harmonic*sympy.exp(I*self.ns[i]*self.Xs[i]*self.xs[i])
        
        self.mark = mark
        self.setup_symmetric_spectrum(False)
        
        
    def putSums(self):
        #TODO should support x dependant functions (instead of Symbols) 
        # otherwise the time derivatives have to be performed after 
        # calling this function not before
        var_subs = [None]*len(self.vars)
        for i in range(len(self.vars)):
            var_subs[i] = Sum(Symbol(self.mark+'{'+self.vars[i].name+'}')(*tuple(self.ns))
                *self.harmonic,(self.ns[0],-oo,+oo))
            for j in range(1, self.N_Dim):
                var_subs[i] = Sum(var_subs[i], (self.ns[j],-oo,+oo))
            
        
        expr_new = self.expr.subs([(self.vars[i], var_subs[i]) for i in range(len(self.vars))])

        self.varsHarm = [None]*len(self.vars)
        for i in range(len(self.vars)):
            self.varsHarm[i] = Function(self.mark+'{'+self.vars[i].name+'}')
        return expr_new
        
        
    def isFourierSeries(self, expr):
        if expr.func != Sum:
            return False
        args = expr.args
        if len(args)!=self.N_Dim+1:
            return False
        if not args[0].has(self.harmonic):
            return False
        for i in range(self.N_Dim):
            if args[i+1]!=(self.ns[i], -oo, +oo):
                return False
        return True
        
        
    def getCoefficientPartOfSeries(self, expr):
        if expr.func != Sum:
            raise ValueError('expression is not a Fourier series!')
        args = expr.args
        if len(args)!=self.N_Dim+1:
            raise ValueError('expression is not a Fourier series!')
        if not args[0].has(self.harmonic):
            raise ValueError('expression is not a Fourier series!')
        for i in range(self.N_Dim):
            if args[i+1]!=(self.ns[i], -oo, +oo):
                raise ValueError('expression is not a Fourier series!')
        expr_coeff = args[0]/self.harmonic
        return expr_coeff
        
        
    def MultiplySeries_Convulve(self, expr1, expr2):
        expr1_coeff = self.getCoefficientPartOfSeries(expr1)
        expr2_coeff = self.getCoefficientPartOfSeries(expr2)
        dummys = [None]*self.N_Dim
        for i in range(self.N_Dim):
            dummys[i] = Symbol(self.dummys_str[0] + '_' + str(i))
        expr1_coeff = expr1_coeff.subs([(self.ns[i], dummys[i]) for i in range(self.N_Dim)])
        expr2_coeff = expr2_coeff.subs([(self.ns[i], self.ns[i] - dummys[i]) for i in range(self.N_Dim)])
        
        expr_new_coeff = Sum(expr1_coeff*expr2_coeff, (dummys[0],-oo,oo))
        for j in range(1, self.N_Dim):
            expr_new_coeff = Sum(expr_new_coeff, (dummys[j],-oo,+oo))
        
        expr_new = Sum(expr_new_coeff*self.harmonic, (self.ns[0], -oo, oo))
        for j in range(1, self.N_Dim):
            expr_new = Sum(expr_new, (self.ns[j],-oo,+oo))

        return expr_new


    def applyConvolutionToNode(self, node):
        """Apply convolution to node if it contains multiplication of series
        """
        if node[2] == Mul:
            for i, arg_i in  enumerate(node[3]):
                if self.isFourierSeries(arg_i[1]):
                    for j, arg_j in enumerate(node[3]):
                        if i<j:
                            if self.isFourierSeries(arg_j[1]):
                                expr_conv = self.MultiplySeries_Convulve(arg_i[1], arg_j[1])
                                node[3][i][1] = expr_conv
                                del node[3][j]
                                node[1] = node[2](*tuple(node[3][k][1] for k in range(len(node[3]))))
                                symExpr_update_tree(node)
                                return True
        return False
        
        
    def applyConvolutions_walk_tree(self, node):
        self.applyConvolutionToNode(node)
        for arg_i in node[3]:
            if len(arg_i)>0:
                self.applyConvolutions_walk_tree(arg_i)
        return

    def applyConvolutions(self, expr):
        """Apply convolutions
        the equations should be expanded first in order to properly recognize
        the multiplication of 2 series
        """
        expr_expanded = expand(expr)
        expr_tree = symExpr_generate_tree(expr_expanded)
        self.applyConvolutions_walk_tree(expr_tree)
        return expr_tree[1]

    def aSumb_to_Sumab(self, node):
        """ If the expression at a given node is a*Sum(b*harmonic)
        it will be modified to Sum(a*b*harmonic)
        """
        if node[2]==Mul:
            for i, arg_i in enumerate(node[3]):
                if self.isFourierSeries(arg_i[1]):
                    coeff_in = self.getCoefficientPartOfSeries(arg_i[1])
                    mul_args_except_sum = [node[3][k][1] for k in range(len(node[3]))]
                    del mul_args_except_sum[i]
                    coeff_out = Mul(*tuple(mul_args_except_sum))
                    
                    node[1] = Sum(coeff_out*coeff_in*self.harmonic, (self.ns[0],-oo,oo))
                    for j in range(1, self.N_Dim):
                        node[1] = Sum(node[1], (self.ns[j],-oo,+oo))
                    symExpr_update_tree(node)
                    return True
        return False
        
    
    def aSumb_to_Sumab_walk_tree(self, node):
        self.aSumb_to_Sumab(node)
        for arg_i in node[3]:
            if len(arg_i)>0:
                self.aSumb_to_Sumab_walk_tree(arg_i)
        return
        

    def SumaPlusSumb_to_SumaPlusb(self, node):
        """ If the expression at a given node is Sum(a*harmonic) + Sum(b*harmonic)
        it will be modified to Sum((a+b)*harmonic)
        """
        if node[2]==Add:
            for i, arg_i in enumerate(node[3]):
                if self.isFourierSeries(arg_i[1]):
                    for j, arg_j in enumerate(node[3]):
                        if i<j:
                            if self.isFourierSeries(arg_j[1]):
                                coeff_i = self.getCoefficientPartOfSeries(arg_i[1])
                                coeff_j = self.getCoefficientPartOfSeries(arg_j[1])
                                if len(node[3])==2:
                                    node[1] = Sum((coeff_i+coeff_j)*self.harmonic, (self.ns[0],-oo,oo))
                                    for k in range(1, self.N_Dim):
                                        node[1] = Sum(node[1], (self.ns[k],-oo,+oo))
                                    symExpr_update_tree(node)
                                    return True
                                else:
                                    node_1_arg = [node[3][k][1] for k in range(len(node[3]))]
                                    del node_1_arg[j]
                                    del node_1_arg[i]
                                    sum_i_j = Sum((coeff_i+coeff_j)*self.harmonic, (self.ns[0],-oo,oo))
                                    for k in range(1, self.N_Dim):
                                        sum_i_j = Sum(sum_i_j, (self.ns[k],-oo,+oo))
                                    node_1_arg.append(sum_i_j)
                                    node[1] = node[2](*tuple(node_1_arg))
                                    symExpr_update_tree(node)
                                    self.SumaPlusSumb_to_SumaPlusb(node)
                                    return True
        return False
        

    def SumaPlusSumb_to_SumaPlusb_walk_tree(self, node):
        self.SumaPlusSumb_to_SumaPlusb(node)
        for arg_i in node[3]:
            if len(arg_i)>0:
                self.SumaPlusSumb_to_SumaPlusb_walk_tree(arg_i)
        return


    def addSeriesManually(self, expr):
        expr_expanded = expand(expr)
        expr_tree = symExpr_generate_tree(expr_expanded)
        self.aSumb_to_Sumab_walk_tree(expr_tree)
        self.SumaPlusSumb_to_SumaPlusb_walk_tree(expr_tree)
        return expr_tree[1]


    def applyOrthogonalities(self, expr):
        expr = self.addSeriesManually(expr)
        if expr.func == Sum:
            return self.getCoefficientPartOfSeries(expr)
        elif expr == 0:
            return 0
        else:
            from IPython.display import display, Math, Latex
            from sympy import latex
            display(Math('expr = ' + latex(expr)))
            print(expr)
            raise ValueError("Orthogonality was not assured..")
            return None



    def aSumb_to_Sumab_truncated(self, node):
        """ If the expression at a given node is a*Sum(b, limits)
        it will be modified to Sum(a*b, limits)
        """
        if node[2]==Mul:
            for i, arg_i in enumerate(node[3]):
                if arg_i[2]==Sum:
                    assert len(arg_i[3])==self.N_Dim+1
                    coeff_in = arg_i[3][0][1]
                    for j in range(self.N_Dim):
                        sum_limits_arg = arg_i[3][j+1][1]
                        assert sum_limits_arg.func==Tuple
                        dummy = sum_limits_arg.args[0].name    # 'n_1' or 'n_2' ...
                        dummy_nodigits = ''.join([k for k in dummy if not (k.isdigit() or k=='_')])
                        assert dummy_nodigits in self.dummys
                    mul_args_except_sum = [node[3][k][1] for k in range(len(node[3]))]
                    del mul_args_except_sum[i]
                    coeff_out = Mul(*tuple(mul_args_except_sum))
                    
                    for j in range(self.N_Dim):
                        sum_limits_arg = arg_i[3][j+1][1]
                        assert not coeff_out.has(sum_limits_arg.args[0])
                            
                    sum_limits_arg = arg_i[3][1][1]
                    node[1] = Sum(coeff_out*coeff_in, sum_limits_arg)
                    for j in range(1, self.N_Dim):
                        sum_limits_arg = arg_i[3][j+1][1]
                        node[1] = Sum(node[1], sum_limits_arg)
                    symExpr_update_tree(node)
                    return True
        return False

    def aSumb_to_Sumab_truncated_walk_tree(self, node):
        self.aSumb_to_Sumab_truncated(node)
        for arg_i in node[3]:
            if len(arg_i)>0:
                self.aSumb_to_Sumab_truncated_walk_tree(arg_i)
        return
        

    def find_node_with_function(self, node, f):
        """ finds the first node whose node[2] component is the given function f and returns
            it starts from the given node and walks down the tree
        """
        if node[2]==f:
            return node
        else:
            for arg in node[3]:
                subnode_f = self.find_node_with_function(arg, f)
                if subnode_f!=False:
                    return subnode_f
        return False

    def find_node_with_symbol(self, node, x):
        """ finds the first node whose node[1] component is the given symbol x and returns
            it starts from the given node and walks down the tree
        """
        if node[1]==x:
            return node
        else:
            for arg in node[3]:
                subnode_x = self.find_node_with_symbol(arg, x)
                if subnode_x!=False:
                    return subnode_x
        return False


    def find_mult_coeff_of_func(self, node, var):
        """ 
        Finds the multiplicative coefficients of a given variable in an expression 
        linear in var.
        var is a Function. Its argumet may contain Symbol(n_str) or Symbol(n_str+'_1')..
        """
        if isinstance(node, list):
            if node[2]==var:
                var_coeff = 1
                var_arg = node[1].args
                var_ind = node[4]
                parent = node[0]
                while parent!=None:
                    if not(parent[2]==Mul or parent[2]==Add or parent[2]==Sum):
                        print(parent[2])
                        raise NotImplementedError("only Mul, Add are treated")
                    if parent[2]==Mul:
                        mul_args_parent = [parent[3][k][1] for k in range(len(parent[3])) if k!=var_ind]
                        var_coeff *= Mul(*tuple(mul_args_parent))
                    var_ind = parent[4]     ##++
                    parent = parent[0]
                coeff_arg = [var_coeff, var_arg]
                return coeff_arg
            return False
        else:
            expr_tree = symExpr_generate_tree(node)
            node_var = find_node_with_function(expr_tree, var)
            if node_var!=False:
                return d1_find_mult_coeff_of_func(node_var, var)
            return False


    def getcoeff_setzero(self, node, var):
        """ var is a Function. Its argumet may contain Symbol(n_str) or Symbol(n_str+'_1')..
        """
        node_var = self.find_node_with_function(node, var)
        if node_var!=False:
             var_coeff_and_arg = self.find_mult_coeff_of_func(node_var, var)
             node_var[1] = Integer(0)
             symExpr_update_tree(node_var)
             return var_coeff_and_arg    # [var_coeff, var_arg]
        return False

    def remove_sums_of_zero_arg(self, node):
        """
        removes Sum functions whose argumet is zero
        """
        if node[2]==Sum:
            if node[1].args[0]==0:
                node[1] = Integer(0)    
                symExpr_update_tree(node)
        for arg in node[3]:
            if len(arg)>0:
                self.remove_sums_of_zero_arg(arg)
        return


    #-- numerical part
    
    def setup_symmetric_spectrum(self, sym):
        if sym==True:
            self.symmetric_spec = True
        elif sym==False:
            self.symmetric_spec = False
        else:
            raise ValueError('takes boolean input')
        return

    def setupNumericalParameters(self, expr_list, n_str, Ns, pars, pars_vecs, eig_vars):
        """
           expr_list: sympy expression list (the given system of equations: expr_list[i]=0)
           N: number of Fourier harmonics (-N...N-1) or (-N...N)
           vars: list containing unknown fourier variables
           pars: list containing known Fourier parameters
           pars_vecs: list containig numpy arrays holding the coefficients of each variable
                  in pars
           eig_vars: list containing unknown scalars (usually the eigenvalue)
        """
        self.expr_list = expr_list
        self.Ns = Ns
        self.pars = pars
        self.pars_vecs = pars_vecs
        self.eig_vars = eig_vars
        
        N_mp = 0
        for i in range(self.N_Dim):
            N = Ns[i]
            NF_0 = -N
            NF_1 = N
            if self.symmetric_spec==True:
                NF_1 = N + 1
            N_mp += NF_1 - NF_0  #2*N  # Fourier indexes _N...N-1: 2*N (for speed)
        
        self.N_mp = N_mp
        self.n_total = N_mp*len(self.vars)
        if len(self.expr_list)!=len(self.vars):
            raise ValueError('number of equations should be equal to the number of \
                variables')


    def orthogonalToNumpyMatrix(self):
        """It takes the orthogonal Fourier expression and generates a numpy matrix
            to solve.
        """
        expr_list = self.expr_list
        Ns = self.Ns
        pars = self.pars
        pars_vecs = self.pars_vecs
        eig_vars = self.eig_vars
        vars = self.vars
        

        def var_index(v, i_n):
            v_ind = i_n[0] + Ns[0]
            if self.symmetric_spec==True:
                for i in range(1, self.N_Dim):
                    v_ind += (i_n[i] + Ns[i])*(2*Ns[i-1]+1)
            else:
                for i in range(1, self.N_Dim):
                    v_ind += (i_n[i] + Ns[i])*2*Ns[i-1]
            return v*N_mp + v_ind
        
        n_total = self.n_total

        ### matrices
        A_lin_sp = csr_matrix( (n_total,n_total), dtype=complex)
        A_eig_sp_list = []
        A_convs = np.zeros((n_total, n_total), dtype=complex)
        b_rhs = np.zeros((n_total, 1))
        for eq_ind, expr in enumerate(expr_list):
            expr_expanded = expand(expr)
            expr_tree = symExpr_generate_tree(expr_expanded)
            self.aSumb_to_Sumab_truncated_walk_tree(expr_tree)
            for ind_v, var in enumerate(vars):
                while True:
                    coeff_arg = self.getcoeff_setzero(expr_tree, var)
                    #print('coeff_arg :')
                    #display(Math(latex(coeff_arg)))
                    if coeff_arg==False:
                        break
                    else:
                        coeff, arg = coeff_arg
                        for var_ in vars:
                            if coeff.has(var_):
                                raise ValueError('Equation is not linear.')
                        n_par = 0    # number of periodic parameters involved
                        for par in pars:
                            if coeff.has(par):
                                n_par += 1
                        n_eg = 0    # number of eigen variables involved
                        for eg in eig_vars:
                            if coeff.has(eg):
                                n_eg += 1
                        if n_par==0:
                            if n_eg==0:
                                a_lin_sp_coo = d1_orth_ToNumpyMatrix_const_coeff(coeff,
                                       arg, n_str, N, n_total, ind_v, eq_ind*N_mp)
                                A_lin_sp = A_lin_sp + a_lin_sp_coo.tocsr()
                            else:
                                A_eig, a_eig_sp_coo = d1_orth_toNumpyMatrix_eig_coeff(coeff,
                                      arg, n_str, N, n_total, ind_v, eq_ind*N_mp, eig_vars)
                                a_eig_sp_csr = a_eig_sp_coo.tocsr()
                                A_eig_sp_list.append([A_eig, a_eig_sp_csr])
                        elif n_par==1:
                            A_dense = d1_orth_ToNumpyMatrix_convolutions(coeff, arg, n_str, N, n_total, 
                             ind_v, eq_ind*N_mp, pars, pars_vecs)
                            A_convs += A_dense
                        else:
                            raise NotImplementedError('more than one periodic coefficient..')
            d1_remove_sums_of_zero_arg(expr_tree)
            if expr_tree[1]!=0:
                # get the rhs
                from IPython.display import display, Math
                print(expr_tree[1])
                display(Math(latex(expr_tree[1])))
                raise NotImplementedError('non-zero rhs not implemented..')
        return [A_lin_sp, A_convs, A_eig_sp_list, b_rhs]


    def orth_ToNumpyMatrix_const_coeff(self, coeff, arg, ind_v, eq_ind_start):
        """
        it takes a coefficient and argument (coeff*var(arg)) depennding only on 
        n_str and returns a sparse numpy matrix
        coeff*vars[var_ind](arg)
        coeff: coefficient expression
        arg: argument expression
        ind_v: index of the variable inside vars
        eq_ind_start: index of the first equation (row indices - 0-based)
        """
        def var_index(i_n):
            for i in range(self.N_Dim):
                NF_0 = -self.Ns[i]
                NF_1 = self.Ns[i]
                if self.symmetric_spec:
                    NF_1 = self.Ns[i]+1
                if not NF_0<=i_n[i]<NF_1:
                    return -1
            v = ind_v
            vi_ind = i_n[0] + Ns[0]
            if self.symmetric_spec==True:
                for i in range(1, self.N_Dim):
                    vi_ind += (i_n[i] + Ns[i])*(2*Ns[i-1]+1)
            else:
                for i in range(1, self.N_Dim):
                    vi_ind += (i_n[i] + Ns[i])*2*Ns[i-1]
            return v*self.N_mp + vi_ind
        
        #var_index_np = np.frompyfunc(var_index,1,1)

        def eq_index(i_n):
            eqi_ind = i_n[0] + Ns[0]
            if self.symmetric_spec==True:
                for i in range(1, self.N_Dim):
                    eqi_ind += (i_n[i] + Ns[i])*(2*Ns[i-1]+1)
            else:
                for i in range(1, self.N_Dim):
                    eqi_ind += (i_n[i] + Ns[i])*2*Ns[i-1]
            return eq_ind_start + eqi_ind
            
        #eq_index_np = np.frompyfunc(eq_index,1,1) 
        
        def increase_i_n(i_n):
            if self.symmetric_spec:
                for i in range(self.N_Dim):
                    if i_n[i]<self.Ns[i]:
                        i_n[i] += 1
                        return True
                    else:
                        i_n[i] = -self.Ns[i]
            else:
                for i in range(self.N_Dim):
                    if i_n[i]<self.Ns[i]-1:
                        i_n[i] += 1
                        return True
                    else:
                        i_n[i] = -self.Ns[i]
            return False
            
        f_coeff = lambdify(tuple(self.ns), coeff)
        f_arg = lambdify(tuple(self.ns), arg)
        
        i_n = [None]*self.N_Dim
        for i in range(self.N_Dim):
            i_n[i] = -self.Ns[i]
            
        col = [-1]*self.N_mp
        row = [-1]*self.N_mp
        data = [-1]*self.N_mp
        
        ind = 0
        while True:
            col[ind] = var_index(list(f_arg(*tuple(i_n))))
            row[ind] = eq_index(i_n)
            data[ind] = f_coeff(i_n)
            ind += 1
            if not increase_i_n(i_n):
                break
        assert ind==self.N_mp
        
        ind_to_remove = []
        for i in range(len(col)-1, -1, -1):
            if col[i]<0:
                del row[i]
                del col[i]
                del data[i]
        
        col = np.array(col)
        row = np.array(row)
        data = np.array(data)
        mat_sp = coo_matrix((data, (row,col)), shape=(n_total,n_total), dtype=complex)
        return mat_sp


    def split_expr(self, expr, symbs_1, symbs_2):
        """
        splits an expression into A(symbs_1)+B(symbs_2) or A(symbs_1)*B(symbs_2)
        symbs_1: list of symbols
        symbs_2: list of symbols
        expr: sympy expression
        """
        #TODO it works only if the top level functions is Add or Mul, 
        # the rest to be done
        if expr.func == Add or expr.func == Mul:
            A, B = [], []
            for arg in list(expr.args):
                toA, toB = True, True
                for x1 in symbs_1:
                    for x2 in symbs_2:
                        if arg.has(x1)==True:
                            toB = False
                        if arg.has(x2)==True:
                            toA = False
                if toA==True:
                    A.append(arg)
                elif toB==True:
                    B.append(arg)
                else:
                    return [False]
            return [True, expr.func, A, B]
        else:
            A_only = True
            for x in symbs_1:
                if expr.has(x):
                    A_only = False
                    break
            if A_only==True:
                return [True, Mul, [expr], [Integer(1)]]
            A_only = True
            for x in symbs_2:
                if expr.has(x):
                    A_only = False
                    break
            if A_only==True:
                return [True, Mul, [expr], [Integer(1)]]
                    
            raise NotImplementedError('Functions other than Add and Mul not imple\
            mented')
        return [False]


    def orth_toNumpyMatrix_eig_coeff(self, coeff, arg, ind_v, eq_ind_start):
        """
        it takes a coefficient and argument (coeff(eig_vars)*var(arg)), where 
        coeff is a function of eig_vars and n_str 
        and returns a sparse numpy matrix multiplied by an expression depending
        only on eig_vars as symbols
        coeff*vars[var_ind](arg)
        coeff: coefficient expression
        arg: argument expression
        n_str: fourier index (usually n)
        N: number of Fourier harmonics to keep
        n_total: total number of variables
        ind_v: index of the variable inside vars
        eq_ind_start: index of the first equation (row indices)
        eig_vars: eigenvalue parameters
        """
        eig_vars = self.eig_vars
        
        expr_split = self.split_expr(coeff.expand(), eig_vars, self.ns)
        if expr_split[0]==False:
            raise NotImplementedError('not implemented')
        if expr_split[1]==Add:
            raise NotImplementedError('not implemented: expression should have \
            been already expanded')
        ## coeff = A(eigs)*B(n)
        A_eigs = expr_split[1](*tuple(expr_split[2]))
        B_n = expr_split[1](*tuple(expr_split[3]))
        #print('A_eigs :', A_eigs)
        #print('B_n :', B_n)
        mat_sp = self.orth_ToNumpyMatrix_const_coeff(B_n, arg, ind_v, eq_ind_start)
        return [A_eigs, mat_sp] ## A_eigs*mat_sp



    def get_func_arg(self, expr, func):
        """
        finds the first instance of the func and returns its argument
        """
        expr_tree = symExpr_generate_tree(expr)
        node_func = self.find_node_with_function(expr_tree, func)
        if node_func!=False:
            return  node_func[1].args
        return False


    def orth_ToNumpyMatrix_convolutions(coeff, arg, ind_v, eq_ind_start):
        """
        it takes a coefficient and argument (coeff*var(arg)) depennding only on 
        n_str or n_str_i (a convolution sum) and returns a sparse numpy matrix
        coeff*vars[var_ind](arg)
        coeff: coefficient expression involving functions taking n, n_1 as arguments
        arg: argument expression (involving n and/or n_1)
        n_str: fourier index (usually n)
        N: number of Fourier harmonics to keep
        n_total: total number of variables
        ind_v: index of the variable inside vars
        eq_ind_start: index of the first equation (row indices)
        pars: list of periodic parameters
        pars_vecs: list of Fourier coefficients of periodic parameters
        """
        pars = self.pars 
        pars_vecs = self.pars_vecs
        
        def var_index(i_n):
            for i in range(self.N_Dim):
                NF_0 = -self.Ns[i]
                NF_1 = self.Ns[i]
                if self.symmetric_spec:
                    NF_1 = self.Ns[i]+1
                if not NF_0<=i_n[i]<NF_1:
                    return -1
            v = ind_v
            vi_ind = i_n[0] + Ns[0]
            if self.symmetric_spec==True:
                for i in range(1, self.N_Dim):
                    vi_ind += (i_n[i] + Ns[i])*(2*Ns[i-1]+1)
            else:
                for i in range(1, self.N_Dim):
                    vi_ind += (i_n[i] + Ns[i])*2*Ns[i-1]
            return v*self.N_mp + vi_ind
        
        #var_index_np = np.frompyfunc(var_index,1,1)

        def eq_index(i_n):
            eqi_ind = i_n[0] + Ns[0]
            if self.symmetric_spec==True:
                for i in range(1, self.N_Dim):
                    eqi_ind += (i_n[i] + Ns[i])*(2*Ns[i-1]+1)
            else:
                for i in range(1, self.N_Dim):
                    eqi_ind += (i_n[i] + Ns[i])*2*Ns[i-1]
            return eq_ind_start + eqi_ind
            
        #eq_index_np = np.frompyfunc(eq_index,1,1) 
        
        def increase_i_n(i_n):
            if self.symmetric_spec:
                for i in range(self.N_Dim):
                    if i_n[i]<self.Ns[i]:
                        i_n[i] += 1
                        return True
                    else:
                        i_n[i] = -self.Ns[i]
            else:
                for i in range(self.N_Dim):
                    if i_n[i]<self.Ns[i]-1:
                        i_n[i] += 1
                        return True
                    else:
                        i_n[i] = -self.Ns[i]
            return False

        # get argumet and coeff of the periodic parameter
        p_coeff = None
        p_arg = None
        p_vec = None
        for i, p in enumerate(pars):
            if coeff.has(p):
                p_arg_list = self.get_func_arg(coeff, p)
                if p_arg_list==False or len(p_arg_list)==0:
                    print("p_arg_list: ", p_arg_list)
                    raise ValueError('par should be a periodic function')
                p_arg = p_arg_list[0]
                p_coeff = symExp_replaceFunction(coeff, p, Symbol('AAAZZ'))\
                     .coeff(Symbol('AAAZZ'))
                p_vec = pars_vecs[i]
                break
        for p in pars:
            if p_coeff.has(p):
                raise NotImplementedError('Only one periodic parameter can be handled')
        # constructing functions

        f_p_coeff = lambdify(tuple(self.ns), p_coeff)
        dummys = [None]*self.N_Dim
        for i in range(self.N_Dim):
            dummys[i] = Symbol(self.dummys_str[0] + '_' + str(i))
        f_p_arg = lambdify(tuple(self.ns + dummys), p_arg)
        f_arg = lambdify(tuple(self.ns + dummys), arg)
        
        #print('arg = ', arg)
        # constructing the dense coefficien2t matrix
        A_mat = np.zeros((self.n_total, self.n_total), dtype=complex)

        i_n = [None]*self.N_Dim
        for i in range(self.N_Dim):
            i_n[i] = -self.Ns[i]

        while True:
            row_ind = eq_index(i_n)
            __c = f_p_coeff(i_n)
            
            i_m = [None]*self.N_Dim
            for i in range(self.N_Dim):
                i_m[i] = -self.Ns[i]
            while True:
                _ind_v_ = f_arg(tuple(i_n+i_m))
                _ind_p_ = f_p_arg(tuple(i_n+i_m))
                
                is_in_range = True
                for i in range(self.N_Dim):
                    NF_0 = -self.Ns[i]
                    NF_1 = self.Ns[i]
                    if self.symmetric_spec:
                        NF_1 = self.Ns[i]+1
                    if not(NF_0<=_ind_v_[i]<NF_1 and NF_0<=_ind_p_[i]<NF_1):
                        is_in_range = False
                        break
                if is_in_range:
                    col_ind = var_index(list(_ind_v_)))
                    _ind_p_vec = [0]*self.N_Dim
                    for i in range(self.N_Dim):
                        _ind_p_vec[i] + _ind_p_[i] + self.Ns[i]
                    A_mat[row_ind, col_ind] += __c*p_vec[tuple(_ind_p_vec)]
                if not increase_i_n(i_m):
                    break

            if not increase_i_n(i_n):
                break
        return A_mat


    def getMatrix(self, eigvar_vals, A_eqs):
        eig_vars = self.eig_vars
        A_lin_sp, A_convs, A_eig_sp_list, b_rhs = A_eqs
        A_tot = A_convs.copy()
        if A_lin_sp.getnnz()>0:
            A_tot += A_lin_sp
        for i in range(len( A_eig_sp_list)):
            C = complex(A_eig_sp_list[i][0].evalf(subs=dict(zip(eig_vars, eigvar_vals))))
            A_tot +=  C*A_eig_sp_list[i][1]
        return A_tot

    def getDeterminant(self, eigvar_vals, A_eqs_list):
        """
        find the determinant of the eigenvalue system where the eigenvalues are
        given in eigvar_vals
        """
        eig_vars = self.eig_vars
        dets = []
        for A_eqs in A_eqs_list:
            A_lin_sp, A_convs, A_eig_sp_list, b_rhs = A_eqs
            A_tot = A_convs.copy()
            if A_lin_sp.getnnz()>0:
                A_tot += A_lin_sp
            for i in range(len( A_eig_sp_list)):
                C = complex(A_eig_sp_list[i][0].evalf(subs=dict(zip(eig_vars, eigvar_vals))))
                A_tot +=  C*A_eig_sp_list[i][1]
            dets.append(linalg.det(A_tot))
        return dets
        


    def getLogDeterminant(eigvar_vals, A_eqs_list):
        """
        find the logarithm of the determinant of the eigenvalue system where 
        the eigenvalues are given in eigvar_vals
        """
        eig_vars = self.eig_vars
        dets = []
        for A_eqs in A_eqs_list:
            A_lin_sp, A_convs, A_eig_sp_list, b_rhs = A_eqs
            A_tot = A_convs.copy()
            if A_lin_sp.getnnz()>0:
                A_tot += A_lin_sp
            for i in range(len( A_eig_sp_list)):
                C = complex(A_eig_sp_list[i][0].evalf(subs=dict(zip(eig_vars, eigvar_vals))))
                A_tot +=  C*A_eig_sp_list[i][1]
            P, L, U = plu = linalg.lu(A_tot)
            log_det = 0.0
            for i in range(A_tot.shape[0]):
                if U[i,i]==0.0:
                    print('U[i,i]==0.0')
                    #print(A_tot)
                    log_det = -300.0    ## TODO: handle log(0)
                    break
                log_det += cmath.log((U[i,i]))
            log_det += cmath.log(linalg.det(P))
            dets.append(log_det)
        return dets

        
        
    def solveDeterminant(eigvar_vals_0, A_eqs_list,
            solver='lm', handle_overflow=False, roots_prev=None):
        """
        solves the determinant for eigenvalues
        x_indep: independant sympy variables (list), 
        x_dep: dependant sympy variables (expressible in terms of x_indep), 
        f_x_dep: python function f describing x_dep = f(x_indep) 
        x_indep_0: x_indep guess value (starting point)
        """
        eig_vars = self.eig_vars
        if len(A_eqs_list)!=len(eig_vars):
            raise ValueError("Error: len(A_eqs_list)!=len(eig_vars")
        if solver=='muller':
            from Misc import solveMuller
            if len(eig_vars)==1:
                log_det_0 = 0.0
                if handle_overflow == True:
                    log_det_0 = d1_getLogDeterminant(eig_vars, eigvar_vals_0, 
                                A_eqs_list)[0]
                def f(x):
                    eigvar_vals = [x]
                    if handle_overflow == False:
                        det_ = d1_getDeterminant(eig_vars, eigvar_vals, 
                               A_eqs_list)[0]
                        return det_
                    else:
                        log_det = d1_getLogDeterminant(eig_vars, eigvar_vals, 
                                A_eqs_list)[0]
                        det_ = cmath.exp(log_det - log_det_0)
                        return det_
                x_0 = eigvar_vals_0[0]
                x_1 = 1.1*x_0
                x_2 = 1.2*x_0
                if x_0==0.0:
                    x_1 = 1.0
                    x_2 = 2.0
                x_muller = solveMuller(f, x_0, x_1, x_2)
                if x_muller[3]==None:
                    print('number of tries: ', x_muller[2])
                    return [[x_muller[0]], [x_muller[1]]]
                else:
                    raise ValueError('Solver did not converge: ' + x_muller[3])
            else:
                raise NotImplementedError('Muller handles only one independant \
                    eigenvalue variable')
        else:
            methods_list = ['hybr', 'lm', 'broyden1', 'broyden2', 'anderson',
                            'linearmixing', 'diagbroyden', 'excitingmixing',
                            'krylov']
            if solver in methods_list==False:
                raise ValueError('Available methods: {0}'.format(methods_list))
            log_det_0 = d1_getLogDeterminant(eig_vars, eigvar_vals_0, A_eqs_list)
            det_0 = d1_getDeterminant(eig_vars, eigvar_vals_0, A_eqs_list)
            #print("xxxxxx det_0", det_0,  "  log_det_0: ", log_det_0)
            def f(x_ri):
                eigvar_vals = []
                for i in range(int(len(x_ri)/2)):
                    eigvar_vals.append(x_ri[2*i] + 1.0j*x_ri[2*i+1])
                if handle_overflow == False:
                    dets_ = d1_getDeterminant(eig_vars, eigvar_vals, 
                           A_eqs_list)
                    dets_ri = []
                    for i in range(len(dets_)):
                        det_ = dets_[i]/det_0[i]
                        if roots_prev!=None:
                            for j in range(len(roots_prev)):
                                for k in range(len(eigvar_vals)):
                                    det_ /= (eigvar_vals[k] - roots_prev[j][k])
                        dets_ri.append(det_.real)
                        dets_ri.append(det_.imag)
                    return dets_ri
                else:
                    log_dets_ = d1_getLogDeterminant(eig_vars, eigvar_vals, 
                            A_eqs_list)
                    dets_ri = []
                    for i in range(len(log_dets_)):
                        det_ = cmath.exp(log_dets_[i] - log_det_0[i])
                        ## TODO: depending on log_det_0 might return a math range error
                        if roots_prev!=None:
                            for j in range(len(roots_prev)):
                                for k in range(len(eigvar_vals)):
                                    det_ /= (eigvar_vals[k] - roots_prev[j][k])
                        dets_ri.append(det_.real)
                        dets_ri.append(det_.imag)
                    #print(x_ri, ' '*20, dets_ri)
                    return dets_ri
            from scipy import optimize
            #print('optimize.root started')
            x_0 = []
            for i in range(len(eigvar_vals_0)):
                x_0.append(eigvar_vals_0[i].real)
                x_0.append(eigvar_vals_0[i].imag)
            tol, maxfev, maxiter = 1.0e-10, 1000, 1000
            sol = optimize.root(f, x_0, method=solver, tol=tol, 
                options={'maxfev':maxfev, 'maxiter':maxiter, 'ftol': 1.0e-5})
            #print('tol: ', tol, '  maxfev: ', maxfev, '  maxiter:', maxiter)
            sol_x = sol.x
            sol_f = sol.fun
            x_ = []
            for i in range(int(len(sol_x)/2)):
                x_.append(sol_x[2*i] + 1j*sol_x[2*i+1])
            f_ = []
            for i in range(int(len(sol_f)/2)):
                f_.append(sol_f[2*i] + 1j*sol_f[2*i+1])
            return [x_, f_, sol]
            
        return

    @staticmethod
    def getFourierCoeffs(f, x_0, x_1, N):
        """
        returns the 1d Fourier coeffs of a function that takes a numpy array as input
        harmonics from NF_0...NF_1-1
        x_0, x_1: limit points of the periodic domain
        N: maximum harmonic index 
        """
        NF_0 = -N
        NF_1 = N
        if d1_symmetric_spec==True:
            NF_1 = N + 1
        N_t = NF_1 - NF_0
        x = np.linspace(x_0, x_1, N_t, endpoint=False)
        f_x = f(x)
        fft_x = fftpack.fftshift(fftpack.fft(f_x))/N_t
        return fft_x
        
    @staticmethod
    def getInverseFourierCoeffs(fft_x):
        """
        returns the function samples given its 1d Fourier coeffs
        """
        f_x = fftpack.ifft(fftpack.ifftshift(fft_x))*len(fft_x)
        return f_x   
        





        
