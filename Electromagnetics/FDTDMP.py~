## FDTD 1D 2D 3D

__all__ = ["FDTDMPYEE", "FDTDYEE", "FdtdCmds"]

import numpy as np
import inspect
from multiprocessing import Process, Pipe, Queue
import multiprocessing, logging, sys
multiprocessing.log_to_stderr(logging.DEBUG)
#logger = multiprocessing.log_to_stderr()
#logger.setLevel(logging.DEBUG)

from enum import Enum
class FdtdCmds(Enum):
    quit = 0
    stringcmd = 1
    getArrSlice = 2
    getArrSliceResp = 3

class SFTypes(Enum):
    JePoint = 0
    JmPoint = 1



class FDTDMPYEE:
    def __init__(self, r0, r1, dr, dt, pr_grid):
        """ pr_grid: process grid  Ex: (2, 3, 4) in 3D --> 24 processes
        """
        assert len(r0)==len(r1)==len(dr)==len(pr_grid)
        self.n_dim=len(r0)
        self.pr_grid = pr_grid
        self.processGrid = np.empty(pr_grid, dtype=object)

        self.r0 = np.copy(r0)
        self.r1 = np.copy(r1)
        self.W = self.r1-self.r0
        self.dt = dt
        
        self.tag = 0

        dr_chunk = (r1-r0)/pr_grid
        self.N_chunk = None
        self.dr = None
        if self.n_dim==3:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    for k in range(pr_grid[2]):
                        r0_ch = r0+np.array([i, j, k])*dr_chunk
                        r1_ch = r0_ch + dr_chunk
                        if self.N_chunk==None:
                            self.processGrid[i,j,k] =  FDTDYEE(r0_ch, r1_ch, dr, dt)
                            self.N_chunk = np.copy(self.processGrid[i,j,k].N)
                            self.dr = np.copy(self.processGrid[i,j,k].dr)
                        else:
                            self.processGrid[i,j,k] =  FDTDYEE(r0_ch, r1_ch, dr, dt, force_N=self.N_chunk)
                            assert np.all(self.processGrid[i,j,k].N==self.N_chunk)
                            assert np.all(self.processGrid[i,j,k].dr==self.dr)
                        self.processGrid[i,j,k].SetCartesianIndex(ChunkInd=np.array([i, j, k]), ChunkIndTot=np.copy(pr_grid))
                        self.processGrid[i,j,k].SetCartesianIndexNeighbors()
                            
        elif self.n_dim==2:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    r0_ch = r0+np.array([i, j])*dr_chunk
                    r1_ch = r0_ch + dr_chunk
                    if self.N_chunk==None:
                        self.processGrid[i,j] =  FDTDYEE(r0_ch, r1_ch, dr, dt)
                        self.N_chunk = np.copy(self.processGrid[i,j].N)
                        self.dr = np.copy(self.processGrid[i,j].dr)
                    else:
                        self.processGrid[i,j] =  FDTDYEE(r0_ch, r1_ch, dr, dt, force_N=self.N_chunk)
                        assert np.all(self.processGrid[i,j].N==self.N_chunk)
                        assert np.all(self.processGrid[i,j].dr==self.dr)
                    self.processGrid[i,j].SetCartesianIndex(ChunkInd=np.array([i, j]), ChunkIndTot=np.copy(pr_grid))
                    self.processGrid[i,j].SetCartesianIndexNeighbors()
                            
        elif self.n_dim==1:
            for i in range(pr_grid[0]):
                r0_ch = r0+np.array([i])*dr_chunk
                r1_ch = r0_ch + dr_chunk
                if self.N_chunk==None:
                    self.processGrid[i] =  FDTDYEE(r0_ch, r1_ch, dr, dt)
                    self.N_chunk = np.copy(self.processGrid[i].N)
                    self.dr = np.copy(self.processGrid[i].dr)
                else:
                    self.processGrid[i] =  FDTDYEE(r0_ch, r1_ch, dr, dt, force_N=self.N_chunk)
                    assert np.all(self.processGrid[i].N==self.N_chunk)
                    assert np.all(self.processGrid[i].dr==self.dr)
                self.processGrid[i].SetCartesianIndex(ChunkInd=np.array([i]), ChunkIndTot=np.copy(pr_grid))
                self.processGrid[i].SetCartesianIndexNeighbors()

        print('self.pr_grid:', self.pr_grid, 'self.N_chunk:', self.N_chunk)
        self.SetInterCommunicators()
        self.SetCommandPipes()
        self.StartProcesses()

        self.logProcContents()
        return


    def logProcContents(self):
        pr_grid = self.pr_grid
        if self.n_dim==3:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    for k in range(pr_grid[2]):
                        self.processGrid[i,j,k].LogInfo()
        if self.n_dim==2:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                        self.processGrid[i,j].LogInfo()
        if self.n_dim==1:
            for i in range(pr_grid[0]):
                self.processGrid[i].LogInfo()


                            
    def SetCommandPipes(self):
        pr_grid = self.pr_grid
        self.cmdGrid = np.empty(pr_grid, dtype=object)
        if self.n_dim==3:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    for k in range(pr_grid[2]):
                        cmd, cmd_res = Pipe()
                        self.cmdGrid[i,j,k] = cmd
                        self.processGrid[i,j,k].SetCommandPipe(cmd_res)
        
        elif self.n_dim==2:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    cmd, cmd_res = Pipe()
                    self.cmdGrid[i,j] = cmd
                    self.processGrid[i,j].SetCommandPipe(cmd_res)

        elif self.n_dim==1:
            for i in range(pr_grid[0]):
                cmd, cmd_res = Pipe()
                self.cmdGrid[i] = cmd
                self.processGrid[i].SetCommandPipe(cmd_res)
                                

    def SetInterCommunicators(self):
        pr_grid = self.pr_grid
        if self.n_dim==3:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    for k in range(pr_grid[2]):
                        ChunkIndNB = self.processGrid[i,j,k].ChunkIndNB
                        for n_dir in range(3):
                            if ChunkIndNB['p'][n_dir]!=None:
                                comm, comm_rec = Pipe()
                                grid_ind_nb = ChunkIndNB['p'][n_dir]
                                self.processGrid[i,j,k].AddCommPipesNBSend(grid_ind_nb, comm)
                                self.processGrid[tuple(grid_ind_nb)].AddCommPipesNBRecv(self.pr_grid, comm_rec)
                            if ChunkIndNB['n'][n_dir]!=None:
                                comm, comm_rec = Pipe()
                                grid_ind_nb = ChunkIndNB['n'][n_dir]
                                self.processGrid[i,j,k].AddCommPipesNBSend(grid_ind_nb, comm)
                                self.processGrid[tuple(grid_ind_nb)].AddCommPipesNBRecv(self.pr_grid, comm_rec)
        
        elif self.n_dim==2:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    ChunkIndNB = self.processGrid[i,j].ChunkIndNB
                    for n_dir in range(2):
                        if ChunkIndNB['p'][n_dir]!=None:
                            comm, comm_rec = Pipe()
                            grid_ind_nb = ChunkIndNB['p'][n_dir]
                            self.processGrid[i,j].AddCommPipesNBSend(grid_ind_nb, comm)
                            self.processGrid[tuple(grid_ind_nb)].AddCommPipesNBRecv(self.pr_grid, comm_rec)
                        if ChunkIndNB['n'][n_dir]!=None:
                            comm, comm_rec = Pipe()
                            grid_ind_nb = ChunkIndNB['n'][n_dir]
                            self.processGrid[i,j].AddCommPipesNBSend(grid_ind_nb, comm)
                            self.processGrid[tuple(grid_ind_nb)].AddCommPipesNBRecv(self.pr_grid, comm_rec)

        elif self.n_dim==1:
            for i in range(pr_grid[0]):
                ChunkIndNB = self.processGrid[i].ChunkIndNB
                for n_dir in range(1):
                    if ChunkIndNB['p'][n_dir]!=None:
                        comm, comm_rec = Pipe()
                        grid_ind_nb = ChunkIndNB['p'][n_dir]
                        self.processGrid[i].AddCommPipesNBSend(grid_ind_nb, comm)
                        self.processGrid[tuple(grid_ind_nb)].AddCommPipesNBRecv(self.pr_grid, comm_rec)
                    if ChunkIndNB['n'][n_dir]!=None:
                        comm, comm_rec = Pipe()
                        grid_ind_nb = ChunkIndNB['n'][n_dir]
                        self.processGrid[i].AddCommPipesNBSend(grid_ind_nb, comm)
                        self.processGrid[tuple(grid_ind_nb)].AddCommPipesNBRecv(self.pr_grid, comm_rec)


    def StartProcesses(self):
        pr_grid = self.pr_grid
        if self.n_dim==3:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    for k in range(pr_grid[2]):
                        self.processGrid[i,j,k].start()
        elif self.n_dim==2:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    self.processGrid[i,j].start()
        elif self.n_dim==1:
            for i in range(pr_grid[0]):
                self.processGrid[i].start()
        
    def TerminateProcesses(self):
        pr_grid = self.pr_grid
        if self.n_dim==3:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    for k in range(pr_grid[2]):
                        #self.processGrid[i,j,k].terminate()
                        #assert self.processGrid[i, j, k].quitLoop==True
                        self.processGrid[i,j,k].join()
        elif self.n_dim==2:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    #self.processGrid[i,j].terminate()
                    #assert self.processGrid[i, j].quitLoop==True
                    self.processGrid[i,j].join()
        elif self.n_dim==1:
            for i in range(pr_grid[0]):
                #self.processGrid[i].terminate()
                #assert self.processGrid[i].quitLoop==True
                self.processGrid[i].join()
        
              
    def getUniqueTag(self):
        self.tag += 1
        return self.tag

    def SendQuitMessage(self):
        pr_grid = self.pr_grid
        tag = self.getUniqueTag()
        if self.n_dim==3:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    for k in range(pr_grid[2]):
                        self.cmdGrid[i,j,k].send([FdtdCmds.quit, tag, None, None])
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    for k in range(pr_grid[2]):
                        resp = self.cmdGrid[i,j,k].recv()
                        assert resp[2][0]=='ok'
        elif self.n_dim==2:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    self.cmdGrid[i,j].send([FdtdCmds.quit, None, None, None])
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    resp = self.cmdGrid[i,j].recv()
                    assert resp[2][0]=='ok'
        elif self.n_dim==1:
            for i in range(pr_grid[0]):
                self.cmdGrid[i].send([FdtdCmds.quit, None, None, None])
            for i in range(pr_grid[0]):
                resp = self.cmdGrid[i].recv()
                assert resp[2][0]=='ok'
    
    def SendStrMessage(self, msg_str, msg_ret=None):
        pr_grid = self.pr_grid
        tag = self.getUniqueTag()
        return_dic = {}
        if self.n_dim==3:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    for k in range(pr_grid[2]):
                        self.cmdGrid[i,j,k].send([FdtdCmds.stringcmd, tag, msg_str, msg_ret])
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    for k in range(pr_grid[2]):
                        resp = self.cmdGrid[i,j,k].recv()
                        assert resp[1]==tag and resp[2][0]=='ok'
                        return_dic[(i,j,k)] = resp[2][1]
        elif self.n_dim==2:
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    self.cmdGrid[i,j].send([FdtdCmds.stringcmd, tag, msg_str, msg_ret])
            for i in range(pr_grid[0]):
                for j in range(pr_grid[1]):
                    resp = self.cmdGrid[i,j].recv()
                    assert resp[1]==tag and resp[2][0]=='ok'
                    return_dic[(i,j)] = resp[2][1]
        elif self.n_dim==1:
            for i in range(pr_grid[0]):
                self.cmdGrid[i].send([FdtdCmds.stringcmd, tag, msg_str, msg_ret])
            for i in range(pr_grid[0]):
                resp = self.cmdGrid[i].recv()
                assert resp[1]==tag and resp[2][0]=='ok'
                return_dic[(i,)] = resp[2][1]
        return return_dic



class FDTDYEE(Process):
    
    def __init__(self, r0, r1, dr, dt, N_is_even=None, force_N=None):
        super(FDTDYEE, self).__init__()

        assert len(r0)==len(r1)==len(dr)
        self.n_dim=len(r0)
    
        self.r0 = np.copy(r0)   #3 vectors
        self.r1 = np.copy(r1)
        self.W = self.r1-self.r0
        if force_N==None:
            self.N = (self.W/dr).astype(int)
            if N_is_even!=None:
                assert len(N_is_even)==self.n_dim
                for i in range(self.n_dim):
                    if N_is_even[i]==True:
                        if self.N[i]%2==1:
                            self.N[i] += 1
                    else:
                        if self.N[i]%2==0:
                            self.N[i] += 1
        else:
            self.N = np.copy(force_N)
                
        self.dr = self.W/self.N
        self.dt = dt

        self.dtype = float
        
        if self.n_dim==3:
            self.Nsx = self.N+np.array([0, 1, 1])
            self.Nsy = self.N+np.array([1, 0, 1])
            self.Nsz = self.N+np.array([1, 1, 0])

            self.Nfx = self.N+np.array([1, 0, 0])
            self.Nfy = self.N+np.array([0, 1, 0])
            self.Nfz = self.N+np.array([0, 0, 1])
        elif self.n_dim==2:
            self.Nsx = self.N+np.array([0, 1])
            self.Nsy = self.N+np.array([1, 0])
            self.Nsz = self.N+np.array([1, 1])

            self.Nfx = self.N+np.array([1, 0])
            self.Nfy = self.N+np.array([0, 1])
            self.Nfz = self.N+np.array([0, 0])
        elif self.n_dim==1:
            self.Nsx = self.N+np.array([0])
            self.Nsy = self.N+np.array([1])
            self.Nsz = self.N+np.array([1])

            self.Nfx = self.N+np.array([1])
            self.Nfy = self.N+np.array([0])
            self.Nfz = self.N+np.array([0])
        
        
        self.ViewPlanes = []

        self.ChunkInd = None
        self.ChunkIndTot = None
        
        self.tag = 0
        
        self.cmdPipe = None
        self.commPipesNBDicSend = {}
        self.commPipesNBDicRecv = {}
        self.quitLoop = False
        
        self.CurrentSources = []    ## {'type':xx, 'args':{}, 'var':xx}
        return

        
    def SetupCurrentSource(self, jtype, args, var):
        if jtype==SFTypes.JePoint:
            r0 = args['r0']
            mag = args['mag']
            f_t = args['f_t']
            src_dir = args['src_dir']
            
            f_r = self.GetPointSourceFunc(r0, mag, src_dir, em_type='e')
            self.UpdateFuncSide_space(var, f_r)
            
            jargs = {'r0':r0, 'mag':mag, 'f_t':f_t, 'src_dir':src_dir, 'f_r':f_r}
            
            jdic = {'type':jtype, 'args':jargs, 'var':var}
            self.CurrentSources.append(jdic)
        elif jtype==SFTypes.JmPoint:
            r0 = args['r0']
            mag = args['mag']
            f_t = args['f_t']
            src_dir = args['src_dir']
            
            f_r = self.GetPointSourceFunc(r0, mag, src_dir, em_type='m')
            self.UpdateFuncSide_space(var, f_r)
            
            jargs = {'r0':r0, 'mag':mag, 'f_t':f_t, 'src_dir':src_dir, 'f_r':f_r}
            
            jdic = {'type':jtype, 'args':jargs, 'var':var}
            self.CurrentSources.append(jdic)
            
        return        
        
    def LogInfo(self):
        print('self.ChunkInd:', self.ChunkInd, 'self.ChunkIndTot:', self.ChunkIndTot)
        print('self.ChunkIndNB:', self.ChunkIndNB)
        print('self.cmdPipe:', self.cmdPipe)
        print('self.commPipesNBDicSend: ', self.commPipesNBDicSend)
        print('self.commPipesNBDicRecv: ', self.commPipesNBDicRecv)
        print('self.quitLoop: ', self.quitLoop)
    

    def run(self):
        print('starting process: ', self.ChunkInd)
        while not self.quitLoop:
            ## wait for commands from the main process
            cmd = self.cmdPipe.recv()
            ##process command
            self.runCmd(cmd)
            sys.stdout.flush()
        print('Exiting process: ', self.ChunkInd)
        sys.stdout.flush()
            
    
    def runCmd(self, cmd):
        if cmd[0]==FdtdCmds.stringcmd:
            tag = cmd[1]
            str_cmd = cmd[2]
            exec(str_cmd)
            str_return = cmd[3]
            if str_return!=None:
                self.cmdPipe.send([self.ChunkInd, tag, ['ok', exec(str_return)]])
            else:
                self.cmdPipe.send([self.ChunkInd, tag, ['ok', None]])
        elif cmd[0]==FdtdCmds.quit:
            self.quitLoop = True
            tag = cmd[1]
            self.cmdPipe.send([self.ChunkInd, tag, ['ok', None]])
            print('FdtdCmds.quit message received.', self.ChunkInd, 'self.quitLoop:', self.quitLoop)


    def SetCartesianIndex(self, ChunkInd=None, ChunkIndTot=None):
        """ ChunkInd: np.array(n_dim)
        """
        self.ChunkInd = ChunkInd
        self.ChunkIndTot = ChunkIndTot
        
    def SetCartesianIndexNeighbors(self):
        ChunkIndNB = {'p':[None]*self.n_dim, 'n':[None]*self.n_dim}
        ChunkInd0 = np.zeros(self.n_dim)
        if self.n_dim==3:
            chind_xp = self.ChunkInd + np.array([1, 0, 0], dtype=int)
            if np.all(chind_xp < self.ChunkIndTot):
                ChunkIndNB['p'][0] = chind_xp
            chind_xn = self.ChunkInd - np.array([1, 0, 0], dtype=int)
            if np.all(chind_xn >= ChunkInd0):
                ChunkIndNB['n'][0] = chind_xn

            chind_yp = self.ChunkInd + np.array([0, 1, 0], dtype=int)
            if np.all(chind_yp < self.ChunkIndTot):
                ChunkIndNB['p'][1] = chind_yp
            chind_yn = self.ChunkInd - np.array([0, 1, 0], dtype=int)
            if np.all(chind_yn >= ChunkInd0):
                ChunkIndNB['n'][1] = chind_yn

            chind_zp = self.ChunkInd + np.array([0, 0, 1], dtype=int)
            if np.all(chind_zp < self.ChunkIndTot):
                ChunkIndNB['p'][2] = chind_zp
            chind_zn = self.ChunkInd - np.array([0, 0, 1], dtype=int)
            if np.all(chind_zn >= ChunkInd0):
                ChunkIndNB['n'][2] = chind_zn
                
        elif self.n_dim==2:
            chind_xp = self.ChunkInd + np.array([1, 0], dtype=int)
            if np.all(chind_xp < self.ChunkIndTot):
                ChunkIndNB['p'][0] = chind_xp
            chind_xn = self.ChunkInd - np.array([1, 0], dtype=int)
            if np.all(chind_xn >= ChunkInd0):
                ChunkIndNB['n'][0] = chind_xn

            chind_yp = self.ChunkInd + np.array([0, 1], dtype=int)
            if np.all(chind_yp < self.ChunkIndTot):
                ChunkIndNB['p'][1] = chind_yp
            chind_yn = self.ChunkInd - np.array([0, 1], dtype=int)
            if np.all(chind_yn >= ChunkInd0):
                ChunkIndNB['n'][1] = chind_yn
        
        elif self.n_dim==1:
            chind_xp = self.ChunkInd + np.array([1], dtype=int)
            if np.all(chind_xp < self.ChunkIndTot):
                ChunkIndNB['p'][0] = chind_xp
            chind_xn = self.ChunkInd - np.array([1], dtype=int)
            if np.all(chind_xn >= ChunkInd0):
                ChunkIndNB['n'][0] = chind_xn

        self.ChunkIndNB = ChunkIndNB
        

    def AddCommPipesNBSend(self, grid_ind_nb, commPipeSend):
        """ neighbor to neighbor communication pipes
        """
        self.commPipesNBDicSend[tuple(grid_ind_nb)] = commPipeSend

    def AddCommPipesNBRecv(self, grid_ind_nb, commPipeRecv):
        """ neighbor to neighbor communication pipes
        """
        self.commPipesNBDicRecv[tuple(grid_ind_nb)] = commPipeRecv


    def SetCommandPipe(self, commandPipe):
        """ communication between the main process and this cartesian chunk
        """
        self.cmdPipe = commandPipe
        

    def AllocateSideArr_list(self, str_list):
        for A_str in str_list:
            self.allocateSideArrays(A_str)

    def AllocateFaceArr_list(self, str_list):
        for A_str in str_list:
            self.allocateFaceArrays(A_str)

    def allocateSideArrays(self, A_str):
        cmd_x = "%sx = np.zeros(tuple(self.Nsx), dtype=self.dtype)"%A_str
        cmd_y = "%sy = np.zeros(tuple(self.Nsy), dtype=self.dtype)"%A_str
        cmd_z = "%sz = np.zeros(tuple(self.Nsz), dtype=self.dtype)"%A_str
        exec(cmd_x)
        exec(cmd_y)
        exec(cmd_z)
        
        cmd = "self.%s = [%sx, %sy, %sz]"%(A_str, A_str, A_str, A_str)
        exec(cmd)
        exec("print('self.%s[0].shape:', self.%s[0].shape)"%(A_str, A_str))

    def allocateFaceArrays(self, A_str):
        cmd_x = "%sx = np.zeros(tuple(self.Nfx), dtype=self.dtype)"%A_str
        cmd_y = "%sy = np.zeros(tuple(self.Nfy), dtype=self.dtype)"%A_str
        cmd_z = "%sz = np.zeros(tuple(self.Nfz), dtype=self.dtype)"%A_str
        exec(cmd_x)
        exec(cmd_y)
        exec(cmd_z)

        cmd = "self.%s = [%sx, %sy, %sz]"%(A_str, A_str, A_str, A_str)
        exec(cmd)
        exec("print('self.%s[0].shape:', self.%s[0].shape)"%(A_str, A_str))


    def UpdateSide_dAdt_CurlB_C(self, A, B, C_list=None, a=None, b=None, c_list=None):
        """ Wall indices for A are not updated, it will be later forced to 0
            a*d/dt A = b*curl(B) + c*C
            a, A, b, c, C are side elems
            B is face elem
            it starts with D then C then B
            A is on the left hand side.. the rest on the sight hand side
            
            This function should be replaced with GetCurlFace in the parallel version
        """
        if a==None:
            a = np.ones(3)
        if b==None:
            b = np.ones(3)
        Nfx, Nfy, Nfz = self.Nfx, self.Nfy, self.Nfz
        
        ax, ay, az = a
        bx, by, bz = b

        Ax, Ay, Az = A
        Bx, By, Bz = B

        #print('side', '-'*50)
        #print(np.max(np.abs(Ax)), np.max(np.abs(Ay)), np.max(np.abs(Az)))
        #print(np.max(np.abs(A[0])), np.max(np.abs(A[1])), np.max(np.abs(A[2])))


        dx, dy, dz = [None]*3
        if self.n_dim==3:
            dx, dy, dz = self.dr[0], self.dr[1], self.dr[2]
        elif self.n_dim==2:
            dx, dy, dz = self.dr[0], self.dr[1], None
        elif self.n_dim==1:
            dx, dy, dz = self.dr[0], None, None
        dt = self.dt
        
        if C_list!=None:
            if c_list==None:
                c_list = [None]*len(C_list)
            for i in range(len(C_list)):
                C = C_list[i]
                c = c_list[i]
                if c==None:
                    c = np.ones(3)
                    
                Cx, Cy, Cz = C
                cx, cy, cz = c
                Ax += Cx*(cx*dt/ax)
                Ay += Cy*(cy*dt/ay)
                Az += Cz*(cz*dt/az)

        ax_, ay_, az_ = ax, ay, az
        bx_, by_, bz_ = bx, by, bz

        if self.n_dim==3:
            if type(ax)==np.ndarray:
                ax_ = ax[:, 1:-1, 1:-1]
            if type(bx)==np.ndarray:
                bx_ = bx[:, 1:-1, 1:-1]

            if type(ay)==np.ndarray:
                ay_ = ay[1:-1, :, 1:-1]
            if type(by)==np.ndarray:
                by_ = by[1:-1, :, 1:-1]

            if type(az)==np.ndarray:
                az_ = az[1:-1, 1:-1, :]
            if type(bz)==np.ndarray:
                bz_ = bz[1:-1, 1:-1, :]
        elif self.n_dim==2:
            if type(ax)==np.ndarray:
                ax_ = ax[:, 1:-1]
            if type(bx)==np.ndarray:
                bx_ = bx[:, 1:-1]

            if type(ay)==np.ndarray:
                ay_ = ay[1:-1, :]
            if type(by)==np.ndarray:
                by_ = by[1:-1, :]

            if type(az)==np.ndarray:
                az_ = az[1:-1, 1:-1]
            if type(bz)==np.ndarray:
                bz_ = bz[1:-1, 1:-1]
        elif self.n_dim==1:
            if type(ax)==np.ndarray:
                ax_ = ax[:]
            if type(bx)==np.ndarray:
                bx_ = bx[:]

            if type(ay)==np.ndarray:
                ay_ = ay[1:-1]
            if type(by)==np.ndarray:
                by_ = by[1:-1]

            if type(az)==np.ndarray:
                az_ = az[1:-1]
            if type(bz)==np.ndarray:
                bz_ = bz[1:-1]

        if self.n_dim==3:
            Ax[:, 1:-1, 1:-1] -= (By[:, 1:-1, 1:Nfy[2]] - By[:, 1:-1, 0:Nfy[2]-1])*(bx_*dt/(dz*ax_)) 
            Ax[:, 1:-1, 1:-1] += (Bz[:, 1:Nfz[1], 1:-1] - Bz[:, 0:Nfz[1]-1, 1:-1])*(bx_*dt/(dy*ax_)) 

            Ay[1:-1, :, 1:-1] -= (Bz[1:Nfz[0], :, 1:-1] - Bz[0:Nfz[0]-1, :, 1:-1])*(by_*dt/(dx*ay_)) 
            Ay[1:-1, :, 1:-1] += (Bx[1:-1, :, 1:Nfx[2]] - Bx[1:-1, :, 0:Nfx[2]-1])*(by_*dt/(dz*ay_)) 

            Az[1:-1, 1:-1, :] -= (Bx[1:-1, 1:Nfx[1], :] - Bx[1:-1, 0:Nfx[1]-1, :])*(bz_*dt/(dy*az_)) 
            Az[1:-1, 1:-1, :] += (By[1:Nfy[0], 1:-1, :] - By[0:Nfy[0]-1, 1:-1, :])*(bz_*dt/(dx*az_)) 
        elif self.n_dim==2:
            #Ax[:, 1:-1] -= (By[:, 1:-1    ] - By[:, 1:-1      ])*(bx_*dt/(dz*ax_)) 
            Ax[:, 1:-1] += (Bz[:, 1:Nfz[1]] - Bz[:, 0:Nfz[1]-1])*(bx_*dt/(dy*ax_)) 

            Ay[1:-1, :] -= (Bz[1:Nfz[0], :] - Bz[0:Nfz[0]-1, :])*(by_*dt/(dx*ay_)) 
            #Ay[1:-1, :] += (Bx[1:-1, :    ] - Bx[1:-1, :      ])*(by_*dt/(dz*ay_)) 

            Az[1:-1, 1:-1] -= (Bx[1:-1, 1:Nfx[1]] - Bx[1:-1, 0:Nfx[1]-1])*(bz_*dt/(dy*az_)) 
            Az[1:-1, 1:-1] += (By[1:Nfy[0], 1:-1] - By[0:Nfy[0]-1, 1:-1])*(bz_*dt/(dx*az_)) 
        elif self.n_dim==1:
            #Ax[:] -= (By[:] - By[:])*(bx_*dt/(dz*ax_)) 
            #Ax[:] += (Bz[:] - Bz[:])*(bx_*dt/(dy*ax_)) 

            Ay[1:-1] -= (Bz[1:Nfz[0]] - Bz[0:Nfz[0]-1])*(by_*dt/(dx*ay_)) 
            #Ay[1:-1] += (Bx[1:-1    ] - Bx[1:-1      ])*(by_*dt/(dz*ay_)) 

            #Az[1:-1] -= (Bx[1:-1    ] - Bx[1:-1      ])*(bz_*dt/(dy*az_)) 
            Az[1:-1] += (By[1:Nfy[0]] - By[0:Nfy[0]-1])*(bz_*dt/(dx*az_)) 
                
        ##walls
        ax_ii0, ax_ii1, ax_i0i, ax_i1i = [ax]*4
        bx_ii0, bx_ii1, bx_i0i, bx_i1i = [bx]*4
        ay_0ii, ay_1ii, ay_ii0, ay_ii1 = [ay]*4
        by_0ii, by_1ii, by_ii0, by_ii1 = [by]*4
        az_i0i, az_i1i, az_0ii, az_1ii = [az]*4
        bz_i0i, bz_i1i, bz_0ii, bz_1ii = [bz]*4
        ax_i0, ax_i1 = [ax]*2
        bx_i0, bx_i1 = [bx]*2
        ay_0i, ay_1i = [ay]*2
        by_0i, by_1i = [by]*2
        az_i0, az_i1, az_0i, az_1i = [az]*4
        bz_i0, bz_i1, bz_0i, bz_1i = [bz]*4
        ay_0, ay_1 = [ay]*2
        by_0, by_1 = [by]*2
        az_0, az_1 = [az]*2
        bz_0, bz_1 = [bz]*2
        if self.n_dim==3:
            if type(ax)==np.ndarray:
                ax_ii0 = ax[:, :, 0]
                ax_ii1 = ax[:, :, 1]
                ax_i0i = ax[:, 0, :]
                ax_i1i = ax[:, 1, :]
            if type(bx)==np.ndarray:
                bx_ii0 = bx[:, :, 0]
                bx_ii1 = bx[:, :, 1]
                bx_i0i = bx[:, 0, :]
                bx_i1i = bx[:, 1, :]

            if type(ay)==np.ndarray:
                ay_0ii = ay[0, :, :]
                ay_1ii = ay[1, :, :]
                ay_ii0 = ay[:, :, 0]
                ay_ii1 = ay[:, :, 1]
            if type(by)==np.ndarray:
                by_0ii = by[0, :, :]
                by_1ii = by[1, :, :]
                by_ii0 = by[:, :, 0]
                by_ii1 = by[:, :, 1]

            if type(az)==np.ndarray:
                az_i0i = az[:, 0, :]
                az_i1i = az[:, 1, :]
                az_0ii = az[0, :, :]
                az_1ii = az[1, :, :]
            if type(bz)==np.ndarray:
                bz_i0i = bz[:, 0, :]
                bz_i1i = bz[:, 1, :]
                bz_0ii = bz[0, :, :]
                bz_1ii = bz[1, :, :]

        elif self.n_dim==2:
            if type(ax)==np.ndarray:
                ax_i0 = ax[:, 0]
                ax_i1 = ax[:, 1]
            if type(bx)==np.ndarray:
                bx_i0 = bx[:, 0]
                bx_i1 = bx[:, 1]

            if type(ay)==np.ndarray:
                ay_0i = ay[0, :]
                ay_1i = ay[1, :]
            if type(by)==np.ndarray:
                by_0i = by[0, :]
                by_1i = by[1, :]

            if type(az)==np.ndarray:
                az_i0 = az[:, 0]
                az_i1 = az[:, 1]
                az_0i = az[0, :]
                az_1i = az[1, :]
            if type(bz)==np.ndarray:
                bz_i0 = bz[:, 0]
                bz_i1 = bz[:, 1]
                bz_0i = bz[0, :]
                bz_1i = bz[1, :]
        elif self.n_dim==1:
            if type(ay)==np.ndarray:
                ay_0 = ay[0]
                ay_1 = ay[1]
            if type(by)==np.ndarray:
                by_0 = by[0]
                by_1 = by[1]

            if type(az)==np.ndarray:
                az_0 = az[0]
                az_1 = az[1]
            if type(bz)==np.ndarray:
                bz_0 = bz[0]
                bz_1 = bz[1]
                
        if self.n_dim==3:
            Ax[:, :,  0] -= ( By[:, :, 0       ])*(bx_ii0*dt/(dz*ax_ii0)) 
            Ax[:, :, -1] -= (-By[:, :, Nfy[2]-1])*(bx_ii1*dt/(dz*ax_ii1)) 
            Ax[:, 0 , :] += ( Bz[:, 0,        :])*(bx_i0i*dt/(dy*ax_i0i)) 
            Ax[:,-1 , :] += (-Bz[:, Nfz[1]-1, :])*(bx_i1i*dt/(dy*ax_i1i)) 


            Ay[ 0, :, :] -= ( Bz[0,        :, :])*(by_0ii*dt/(dx*ay_0ii)) 
            Ay[-1, :, :] -= (-Bz[Nfz[0]-1, :, :])*(by_1ii*dt/(dx*ay_1ii)) 
            Ay[:, :,  0] += ( Bx[:, :,        0])*(by_ii0*dt/(dz*ay_ii0)) 
            Ay[:, :, -1] += (-Bx[:, :, Nfx[2]-1])*(by_ii1*dt/(dz*ay_ii1)) 

            Az[:, 0 , :] -= ( Bx[:, 0,        :])*(bz_i0i*dt/(dy*az_i0i)) 
            Az[:, -1, :] -= (-Bx[:, Nfx[1]-1, :])*(bz_i1i*dt/(dy*az_i1i)) 
            Az[0 , :, :] += ( By[0,        :, :])*(bz_0ii*dt/(dx*az_0ii)) 
            Az[-1, :, :] += (-By[Nfy[0]-1, :, :])*(bz_1ii*dt/(dx*az_1ii)) 
        elif self.n_dim==2:
            #Ax[:, 1:-1] -= (By[:, 1:-1    ] - By[:, 1:-1      ])*(bx_*dt/(dz*ax_)) 
            Ax[:, 0] += ( Bz[:, 0       ])*(bx_i0*dt/(dy*ax_i0)) 
            Ax[:,-1] += (-Bz[:, Nfz[1]-1])*(bx_i1*dt/(dy*ax_i1)) 

            Ay[0 , :] -= ( Bz[0,        :])*(by_0i*dt/(dx*ay_0i)) 
            Ay[-1, :] -= (-Bz[Nfz[0]-1, :])*(by_1i*dt/(dx*ay_1i)) 
            #Ay[1:-1, :] += (Bx[1:-1, :    ] - Bx[1:-1, :      ])*(by_*dt/(dz*ay_)) 

            Az[:,  0] -= ( Bx[:, 0       ])*(bz_i0*dt/(dy*az_i0)) 
            Az[:, -1] -= (-Bx[:, Nfx[1]-1])*(bz_i1*dt/(dy*az_i1)) 
            Az[0 , :] += ( By[0,        :])*(bz_0i*dt/(dx*az_0i)) 
            Az[-1, :] += (-By[Nfy[0]-1, :])*(bz_1i*dt/(dx*az_1i)) 
        elif self.n_dim==1:
            #Ax[:] -= (By[:] - By[:])*(bx_*dt/(dz*ax_)) 
            #Ax[:] += (Bz[:] - Bz[:])*(bx_*dt/(dy*ax_)) 

            Ay[0 ] -= ( Bz[0       ])*(by_0*dt/(dx*ay_0)) 
            Ay[-1] -= (-Bz[Nfz[0]-1])*(by_1*dt/(dx*ay_1)) 
            #Ay[1:-1] += (Bx[1:-1    ] - Bx[1:-1      ])*(by_*dt/(dz*ay_)) 

            #Az[1:-1] -= (Bx[1:-1    ] - Bx[1:-1      ])*(bz_*dt/(dy*az_)) 
            Az[0 ] += ( By[0       ])*(bz_0*dt/(dx*az_0)) 
            Az[-1] += (-By[Nfy[0]-1])*(bz_1*dt/(dx*az_1)) 

    
    def GetCurlFace(self, B, b=None):
        """ b*curl(B) B is Face element
            returns side element
        """
        if b==None:
            b = np.ones(3)

        Nfx, Nfy, Nfz = self.Nfx, self.Nfy, self.Nfz
        Bx, By, Bz = B
        bx, by, bz = b

        bx_, by_, bz_ = bx, by, bz

        if self.n_dim==3:
            if type(bx)==np.ndarray:
                bx_ = bx[:, 1:-1, 1:-1]
            if type(by)==np.ndarray:
                by_ = by[1:-1, :, 1:-1]
            if type(bz)==np.ndarray:
                bz_ = bz[1:-1, 1:-1, :]
        elif self.n_dim==2:
            if type(bx)==np.ndarray:
                bx_ = bx[:, 1:-1]
            if type(by)==np.ndarray:
                by_ = by[1:-1, :]
            if type(bz)==np.ndarray:
                bz_ = bz[1:-1, 1:-1]
        elif self.n_dim==1:
            if type(bx)==np.ndarray:
                bx_ = bx[:, 1:-1]
            if type(by)==np.ndarray:
                by_ = by[1:-1, :]
            if type(bz)==np.ndarray:
                bz_ = bz[1:-1, 1:-1]

        dx, dy, dz = [None]*3
        if self.n_dim==3:
            dx, dy, dz = self.dr[0], self.dr[1], self.dr[2]
        elif self.n_dim==2:
            dx, dy, dz = self.dr[0], self.dr[1], None
        elif self.n_dim==1:
            dx, dy, dz = self.dr[0], None, None

        Ax = np.zeros(self.Nsx)
        Ay = np.zeros(self.Nsy)
        Az = np.zeros(self.Nsz)
        
        if self.n_dim==3:
            Ax[:, 1:-1, 1:-1] -= (By[:, 1:-1, 1:Nfy[2]] - By[:, 1:-1, 0:Nfy[2]-1])*(bx_/dz) 
            Ax[:, 1:-1, 1:-1] += (Bz[:, 1:Nfz[1], 1:-1] - Bz[:, 0:Nfz[1]-1, 1:-1])*(bx_/dy) 

            Ay[1:-1, :, 1:-1] -= (Bz[1:Nfz[0], :, 1:-1] - Bz[0:Nfz[0]-1, :, 1:-1])*(by_/dx) 
            Ay[1:-1, :, 1:-1] += (Bx[1:-1, :, 1:Nfx[2]] - Bx[1:-1, :, 0:Nfx[2]-1])*(by_/dz) 

            Az[1:-1, 1:-1, :] -= (Bx[1:-1, 1:Nfx[1], :] - Bx[1:-1, 0:Nfx[1]-1, :])*(bz_/dy) 
            Az[1:-1, 1:-1, :] += (By[1:Nfy[0], 1:-1, :] - By[0:Nfy[0]-1, 1:-1, :])*(bz_/dx)
        elif self.n_dim==2:
            #Ax[:, 1:-1] -= (By[:, 1:-1    ] - By[:, 1:-1      ])*(bx_/dz) 
            Ax[:, 1:-1] += (Bz[:, 1:Nfz[1]] - Bz[:, 0:Nfz[1]-1])*(bx_/dy) 

            Ay[1:-1, :] -= (Bz[1:Nfz[0], :] - Bz[0:Nfz[0]-1, :])*(by_/dx) 
            #Ay[1:-1, :] += (Bx[1:-1, :    ] - Bx[1:-1, :      ])*(by_/dz) 

            Az[1:-1, 1:-1] -= (Bx[1:-1, 1:Nfx[1]] - Bx[1:-1, 0:Nfx[1]-1])*(bz_/dy) 
            Az[1:-1, 1:-1] += (By[1:Nfy[0], 1:-1] - By[0:Nfy[0]-1, 1:-1])*(bz_/dx)
        elif self.n_dim==1:
            #Ax[:] -= (By[:] - By[:])*(bx_/dz) 
            #Ax[:] += (Bz[:] - Bz[:])*(bx_/dy) 

            Ay[1:-1] -= (Bz[1:Nfz[0]] - Bz[0:Nfz[0]-1])*(by_/dx) 
            #Ay[1:-1] += (Bx[1:-1    ] - Bx[1:-1      ])*(by_/dz) 

            #Az[1:-1] -= (Bx[1:-1    ] - Bx[1:-1      ])*(bz_/dy) 
            Az[1:-1] += (By[1:Nfy[0]] - By[0:Nfy[0]-1])*(bz_/dx)
        
        ##walls
        bx_ii0, bx_ii1, bx_i0i, bx_i1i = [bx]*4
        by_0ii, by_1ii, by_ii0, by_ii1 = [by]*4
        bz_i0i, bz_i1i, bz_0ii, bz_1ii = [bz]*4
        bx_i0, bx_i1 = [bx]*2
        by_0i, by_1i = [by]*2
        bz_i0, bz_i1, bz_0i, bz_1i = [bz]*4
        by_0, by_1 = [by]*2
        bz_0, bz_1 = [bz]*2
        if self.n_dim==3:
            if type(bx)==np.ndarray:
                bx_ii0 = bx[:, :, 0]
                bx_ii1 = bx[:, :, 1]
                bx_i0i = bx[:, 0, :]
                bx_i1i = bx[:, 1, :]

            if type(by)==np.ndarray:
                by_0ii = by[0, :, :]
                by_1ii = by[1, :, :]
                by_ii0 = by[:, :, 0]
                by_ii1 = by[:, :, 1]

            if type(bz)==np.ndarray:
                bz_i0i = bz[:, 0, :]
                bz_i1i = bz[:, 1, :]
                bz_0ii = bz[0, :, :]
                bz_1ii = bz[1, :, :]

        elif self.n_dim==2:
            if type(bx)==np.ndarray:
                bx_i0 = bx[:, 0]
                bx_i1 = bx[:, 1]

            if type(by)==np.ndarray:
                by_0i = by[0, :]
                by_1i = by[1, :]

            if type(bz)==np.ndarray:
                bz_i0 = bz[:, 0]
                bz_i1 = bz[:, 1]
                bz_0i = bz[0, :]
                bz_1i = bz[1, :]
        elif self.n_dim==1:
            if type(by)==np.ndarray:
                by_0 = by[0]
                by_1 = by[1]

            if type(bz)==np.ndarray:
                bz_0 = bz[0]
                bz_1 = bz[1]

        if self.n_dim==3:
            Ax[:, :,  0] -= ( By[:, :, 0       ])*(bx_ii0/dz) 
            Ax[:, :, -1] -= (-By[:, :, Nfy[2]-1])*(bx_ii1/dz) 
            Ax[:, 0 , :] += ( Bz[:, 0,        :])*(bx_i0i/dy) 
            Ax[:,-1 , :] += (-Bz[:, Nfz[1]-1, :])*(bx_i1i/dy) 


            Ay[ 0, :, :] -= ( Bz[0,        :, :])*(by_0ii/(dx*ay_0ii)) 
            Ay[-1, :, :] -= (-Bz[Nfz[0]-1, :, :])*(by_1ii/(dx*ay_1ii)) 
            Ay[:, :,  0] += ( Bx[:, :,        0])*(by_ii0/(dz*ay_ii0)) 
            Ay[:, :, -1] += (-Bx[:, :, Nfx[2]-1])*(by_ii1/(dz*ay_ii1)) 

            Az[:, 0 , :] -= ( Bx[:, 0,        :])*(bz_i0i/dy) 
            Az[:, -1, :] -= (-Bx[:, Nfx[1]-1, :])*(bz_i1i/dy) 
            Az[0 , :, :] += ( By[0,        :, :])*(bz_0ii/dx) 
            Az[-1, :, :] += (-By[Nfy[0]-1, :, :])*(bz_1ii/dx) 
        elif self.n_dim==2:
            #Ax[:, 1:-1] -= (By[:, 1:-1    ] - By[:, 1:-1      ])*(bx_*dt/(dz*ax_)) 
            Ax[:, 0] += ( Bz[:, 0       ])*(bx_i0/dy) 
            Ax[:,-1] += (-Bz[:, Nfz[1]-1])*(bx_i1/dy) 

            Ay[0 , :] -= ( Bz[0,        :])*(by_0i/dx) 
            Ay[-1, :] -= (-Bz[Nfz[0]-1, :])*(by_1i/dx) 
            #Ay[1:-1, :] += (Bx[1:-1, :    ] - Bx[1:-1, :      ])*(by_*dt/(dz*ay_)) 

            Az[:,  0] -= ( Bx[:, 0       ])*(bz_i0/dy) 
            Az[:, -1] -= (-Bx[:, Nfx[1]-1])*(bz_i1/dy) 
            Az[0 , :] += ( By[0,        :])*(bz_0i/dx) 
            Az[-1, :] += (-By[Nfy[0]-1, :])*(bz_1i/dx) 
        elif self.n_dim==1:
            #Ax[:] -= (By[:] - By[:])*(bx_*dt/(dz*ax_)) 
            #Ax[:] += (Bz[:] - Bz[:])*(bx_*dt/(dy*ax_)) 

            Ay[0 ] -= ( Bz[0       ])*(by_0/dx) 
            Ay[-1] -= (-Bz[Nfz[0]-1])*(by_1/dx) 
            #Ay[1:-1] += (Bx[1:-1    ] - Bx[1:-1      ])*(by_*dt/(dz*ay_)) 

            #Az[1:-1] -= (Bx[1:-1    ] - Bx[1:-1      ])*(bz_*dt/(dy*az_)) 
            Az[0 ] += ( By[0       ])*(bz_0/dx) 
            Az[-1] += (-By[Nfy[0]-1])*(bz_1/dx) 

        return [Ax, Ay, Az]
        

    ##TODO: corners will be correct?
    def sumCurlFaceWalls(self, A_str):
        """ A_str is the curl and is assumed to have the same name among all processes
        for example self.A
        """
        Nsx, Nsy, Nsz = self.Nsx, self.Nsy, self.Nsz
        A = exec(A_str)
        ChunkIndNB = self.ChunkIndNB
        Ax, Ay, Az = A
        if self.n_dim==3:
            run_later = []
            rl_vars = {}    ## rl_ : run later
            ##------  X 
            ind_nb_xp = ChunkIndNB['p'][0]
            ind_nb_xn = ChunkIndNB['n'][0]
            if ind_nb_xp==None:
                ##now all chunks respond to same messages sent by neighbors on the opposite side
                if ind_nb_xn != None:
                    self.processNeighbArrSliceRequest(ind_nb_xn)
                Ay[Nsy[0]-1, :       , :       ] = 0.0
                Az[Nsz[0]-1, :       , :       ] = 0.0
            else:
                tag = self.getUniqueTag()
                self.sendGetArrSliceCommand(ind_nb_xp, tag, A_str_list=[A_str+'[1][0,:,:]', A_str+'[2][0,:,:]'])
                ##now all chunks respond to same messages sent by neighbors on the opposite side
                if ind_nb_xn != None:
                    self.processNeighbArrSliceRequest(ind_nb_xn)
                Anby_0ii, Anbz_0ii = self.GetArrSliceCommandResp(ind_nb_xp, tag)
                Ay[Nsy[0]-1, :       , :       ] += Anby_0ii
                Az[Nsz[0]-1, :       , :       ] += Anbz_0ii
                rl_vars["Anby_0ii"] = Anby_0ii
                rl_vars["Anbz_0ii"] = Anbz_0ii
                run_later.append('Ay[Nsy[0]-1, :       , :       ] += rl_vars["Anby_0ii"]')
                run_later.append('Az[Nsz[0]-1, :       , :       ] += rl_vars["Anbz_0ii"]')
            if ind_nb_xn==None:
                if ind_nb_xp != None:
                    self.processNeighbArrSliceRequest(ind_nb_xp)
                Ay[0       , :       , :       ] = 0.0
                Az[0       , :       , :       ] = 0.0
            else:
                tag = self.getUniqueTag()
                self.sendGetArrSliceCommand(ind_nb_xn, tag, A_str_list=[A_str+'[1][self.Nsy[0]-1,:,:]', A_str+'[2][self.Nsz[0]-1,:,:]'])
                if ind_nb_xp != None:
                    self.processNeighbArrSliceRequest(ind_nb_xp)
                Anby_1ii, Anbz_1ii = self.GetArrSliceCommandResp(ind_nb_xn, tag)
                Ay[0       , :       , :       ] += Anby_1ii
                Az[0       , :       , :       ] += Anbz_1ii
                rl_vars["Anby_1ii"] = Anby_1ii
                rl_vars["Anbz_1ii"] = Anbz_1ii
                run_later.append('Ay[0       , :       , :       ] += rl_vars["Anby_1ii"]')
                run_later.append('Az[0       , :       , :       ] += rl_vars["Anbz_1ii"]')
            ##----- Y 
            ind_nb_yp = ChunkIndNB['p'][1]
            ind_nb_yn = ChunkIndNB['n'][1]
            if ind_nb_yp==None:
                if ind_nb_yn != None:
                    self.processNeighbArrSliceRequest(ind_nb_yn)
                Ax[:       , Nsx[1]-1, :       ] = 0.0
                Az[:       , Nsz[1]-1, :       ] = 0.0
            else:
                tag = self.getUniqueTag()
                self.sendGetArrSliceCommand(ind_nb_yp, tag, A_str_list=[A_str+'[0][:,0,:]', A_str+'[2][:,0,:]'])
                if ind_nb_yn != None:
                    self.processNeighbArrSliceRequest(ind_nb_yn)
                Anbx_i0i, Anbz_i0i = self.GetArrSliceCommandResp(ind_nb_yp, tag)
                Ax[:       , Nsx[1]-1, :       ] += Anbx_i0i
                Az[:       , Nsz[1]-1, :       ] += Anbz_i0i
                rl_vars["Anbx_i0i"] = Anbx_i0i
                rl_vars["Anbz_i0i"] = Anbz_i0i
                run_later.append('Ax[:       , Nsx[1]-1, :       ] += rl_vars["Anbx_i0i"]')
                run_later.append('Az[:       , Nsz[1]-1, :       ] += rl_vars["Anbz_i0i"]')
            if ind_nb_yn==None:
                if ind_nb_yp != None:
                    self.processNeighbArrSliceRequest(ind_nb_yp)
                Ax[:       , Nsx[1]-1, :       ] = 0.0
                Az[:       , Nsz[1]-1, :       ] = 0.0
            else:
                tag = self.getUniqueTag()
                self.sendGetArrSliceCommand(ind_nb_yn, tag, A_str_list=[A_str+'[0][:,self.Nsx[1]-1,:]', A_str+'[2][:,self.Nsz[1]-1,:]'])
                if ind_nb_yp != None:
                    self.processNeighbArrSliceRequest(ind_nb_yp)
                Anbx_i1i, Anbz_i1i = self.GetArrSliceCommandResp(ind_nb_yn, tag)
                Ax[:       , 0        , :       ] += Anbx_i1i
                Az[:       , 0        , :       ] += Anbz_i1i
                rl_vars["Anbx_i1i"] = Anbx_i1i
                rl_vars["Anbz_i1i"] = Anbz_i1i
                run_later.append('Ax[:       , 0        , :       ] += rl_vars["Anbx_i1i"]')
                run_later.append('Az[:       , 0        , :       ] += rl_vars["Anbz_i1i"]')
            ##----- Z 
            ind_nb_zp = ChunkIndNB['p'][2]
            ind_nb_zn = ChunkIndNB['n'][2]
            if ind_nb_zp==None:
                if ind_nb_zn != None:
                    self.processNeighbArrSliceRequest(ind_nb_zn)
                Ax[:       , :       , Nsx[2]-1] = 0.0
                Ay[:       , :       , Nsy[2]-1] = 0.0
            else:
                tag = self.getUniqueTag()
                self.sendGetArrSliceCommand(ind_nb_zp, tag, A_str_list=[A_str+'[0][:,:,0]', A_str+'[1][:,:,0]'])
                if ind_nb_zn != None:
                    self.processNeighbArrSliceRequest(ind_nb_zn)
                Anbx_ii0, Anby_ii0 = self.GetArrSliceCommandResp(ind_nb_zp, tag)
                Ax[:       , :       , Nsx[2]-1] += Anbx_ii0
                Ay[:       , :       , Nsy[2]-1] += Anby_ii0
                rl_vars["Anbx_ii0"] = Anbx_ii0
                rl_vars["Anby_ii0"] = Anby_ii0
                run_later.append('Ax[:       , :       , Nsx[2]-1] += rl_vars["Anbx_ii0"]')
                run_later.append('Ay[:       , :       , Nsy[2]-1] += rl_vars["Anby_ii0"]')
            if ind_nb_zn==None:
                if ind_nb_zp != None:
                    self.processNeighbArrSliceRequest(ind_nb_zp)
                Ax[:       , :       , 0       ] = 0.0
                Ay[:       , :       , 0       ] = 0.0
            else:
                tag = self.getUniqueTag()
                self.sendGetArrSliceCommand(ind_nb_zn, tag, A_str_list=[A_str+'[0][:,:,Nsx[2]-1]', A_str+'[1][:,:,Nsy[2]-1]'])
                if ind_nb_zp != None:
                    self.processNeighbArrSliceRequest(ind_nb_zp)
                Anbx_ii1, Anby_ii1 = self.GetArrSliceCommandResp(ind_nb_zn, tag)
                Ax[:       , :       , 0       ] += Anbx_ii1
                Ay[:       , :       , 0       ] += Anby_ii1
                rl_vars["Anbx_ii1"] = Anbx_ii1
                rl_vars["Anby_ii1"] = Anby_ii1
                run_later.append('Ax[:       , :       , 0       ] += rl_vars["Anbx_ii1"]')
                run_later.append('Ay[:       , :       , 0       ] += rl_vars["Anby_ii1"]')
                
            for expr in run_later:
                exec(expr)
                
    
    def getUniqueTag(self):
        self.tag += 1
        return self.tag
        
    def processNeighbArrSliceRequest(self, ind_nb):
        req_nb = self.commPipesNBDicRecv[tuple(ind_nb)].recv()
        assert req_nb[0]==FdtdCmds.getArrSlice
        tag_nb = req_nb[1]
        arr_slice_inds = req_nb[2]
        arr_nb = [None]*len(arr_slice_inds)
        for i in range(len(arr_slice_inds)):
            arr_nb[i] = exec(arr_slice_inds[i])
        req_nb_resp = [FdtdCmds.getArrSliceResp, tag_nb, arr_nb]
        self.commPipesNBDicRecv[tuple(ind_nb_xn)].send(req_nb_resp)
        
    
    def sendGetArrSliceCommand(self, ind_nb, tag, A_str_list):
        cmd = [FdtdCmds.getArrSlice , tag, A_str_list]
        self.commPipesNBDicSend[tuple(ind_nb)].send(cmd)
            

    def GetArrSliceCommandResp(self, ind_nb, tag):
        resp = self.commPipesNBDicSend[tuple(ind_nb)].recv()
        assert resp[0]==FdtdCmds.getArrSliceResp
        assert resp[1]==tag
        return resp[2]
        
        
    def UpdateFace_dAdt_CurlB_C(self, A, B, C_list=None, a=None, b=None, c_list=None):
        """ Wall indices for A are not updated, it will be later forced to 0
            a*d/dt A = b*curl(B) + c*C
            a, A, b, c, C are face elems
            B is side elem
        """
        assert False
        if a==None:
            a = np.ones(3)
        if b==None:
            b = np.ones(3)

        Nsx, Nsy, Nsz = self.Nsx, self.Nsy, self.Nsz
        ax, ay, az = a
        bx, by, bz = b

        Ax, Ay, Az = A
        Bx, By, Bz = B
        dx, dy, dz = [None]*3
        if self.n_dim==3:
            dx, dy, dz = self.dr[0], self.dr[1], self.dr[2]
        elif self.n_dim==2:
            dx, dy, dz = self.dr[0], self.dr[1], None
        elif self.n_dim==1:
            dx, dy, dz = self.dr[0], None, None
        dt = self.dt

        if C_list!=None:
            if c_list==None:
                c_list = [None]*len(C_list)
            for i in range(len(C_list)):
                C = C_list[i]
                c = c_list[i]
                if c==None:
                    c = np.ones(3)
                    
                Cx, Cy, Cz = C
                cx, cy, cz = c
                Ax += Cx*(cx*dt/ax)
                Ay += Cy*(cy*dt/ay)
                Az += Cz*(cz*dt/az)

        if self.n_dim==3:
            Ax -= (By[:, :, 1:Nsy[2]] - By[:, :, 0:Nsy[2]-1])*(bx*dt/(dz*ax)) 
            Ax += (Bz[:, 1:Nsz[1], :] - Bz[:, 0:Nsz[1]-1, :])*(bx*dt/(dy*ax)) 

            Ay -= (Bz[1:Nsz[0], :, :] - Bz[0:Nsz[0]-1, :, :])*(by*dt/(dx*ay)) 
            Ay += (Bx[:, :, 1:Nsx[2]] - Bx[:, :, 0:Nsx[2]-1])*(by*dt/(dz*ay)) 

            Az -= (Bx[:, 1:Nsx[1], :] - Bx[:, 0:Nsx[1]-1, :])*(bz*dt/(dy*az)) 
            Az += (By[1:Nsy[0], :, :] - By[0:Nsy[0]-1, :, :])*(bz*dt/(dx*az)) 
        elif self.n_dim==2:
            #Ax -= (By[:, :       ] - By[:, :         ])*(bx*dt/(dz*ax)) 
            Ax += (Bz[:, 1:Nsz[1]] - Bz[:, 0:Nsz[1]-1])*(bx*dt/(dy*ax)) 

            Ay -= (Bz[1:Nsz[0], :] - Bz[0:Nsz[0]-1, :])*(by*dt/(dx*ay)) 
            #Ay += (Bx[:, :       ] - Bx[:, :         ])*(by*dt/(dz*ay)) 

            Az -= (Bx[:, 1:Nsx[1]] - Bx[:, 0:Nsx[1]-1])*(bz*dt/(dy*az)) 
            Az += (By[1:Nsy[0], :] - By[0:Nsy[0]-1, :])*(bz*dt/(dx*az)) 
        elif self.n_dim==1:
            #Ax -= (By[:] - By[:])*(bx*dt/(dz*ax)) 
            #Ax += (Bz[:] - Bz[:])*(bx*dt/(dy*ax)) 

            Ay -= (Bz[1:Nsz[0]] - Bz[0:Nsz[0]-1])*(by*dt/(dx*ay)) 
            #Ay += (Bx[:       ] - Bx[:         ])*(by*dt/(dz*ay)) 

            #Az -= (Bx[:       ] - Bx[:         ])*(bz*dt/(dy*az)) 
            Az += (By[1:Nsy[0]] - By[0:Nsy[0]-1])*(bz*dt/(dx*az)) 


    def GetCurlSide(self, B, b=None):
        """ b*curl(B) B is side element
            returns face element
        """
        if b==None:
            b = np.ones(3)
            
        Nsx, Nsy, Nsz = self.Nsx, self.Nsy, self.Nsz
        Bx, By, Bz = B
        bx, by, bz = b

        dx, dy, dz = [None]*3
        if self.n_dim==3:
            dx, dy, dz = self.dr[0], self.dr[1], self.dr[2]
        elif self.n_dim==2:
            dx, dy, dz = self.dr[0], self.dr[1], None
        elif self.n_dim==1:
            dx, dy, dz = self.dr[0], None, None
        dt = self.dt

        Ax, Ay, Az = np.zeros(self.Nfx), np.zeros(self.Nfy), np.zeros(self.Nfz)
        if self.n_dim==3:
            Ax -= (By[:, :, 1:Nsy[2]] - By[:, :, 0:Nsy[2]-1])*(bx/dz) 
            Ax += (Bz[:, 1:Nsz[1], :] - Bz[:, 0:Nsz[1]-1, :])*(bx/dy) 

            Ay -= (Bz[1:Nsz[0], :, :] - Bz[0:Nsz[0]-1, :, :])*(by/dx) 
            Ay += (Bx[:, :, 1:Nsx[2]] - Bx[:, :, 0:Nsx[2]-1])*(by/dz) 

            Az -= (Bx[:, 1:Nsx[1], :] - Bx[:, 0:Nsx[1]-1, :])*(bz/dy) 
            Az += (By[1:Nsy[0], :, :] - By[0:Nsy[0]-1, :, :])*(bz/dx) 
        if self.n_dim==2:
            #Ax -= (By[:, :       ] - By[:, :         ])*(bx/dz) 
            Ax += (Bz[:, 1:Nsz[1]] - Bz[:, 0:Nsz[1]-1])*(bx/dy) 

            Ay -= (Bz[1:Nsz[0], :] - Bz[0:Nsz[0]-1, :])*(by/dx) 
            #Ay += (Bx[:, :       ] - Bx[:, :         ])*(by/dz) 

            Az -= (Bx[:, 1:Nsx[1]] - Bx[:, 0:Nsx[1]-1])*(bz/dy) 
            Az += (By[1:Nsy[0], :] - By[0:Nsy[0]-1, :])*(bz/dx) 
        if self.n_dim==1:
            #Ax -= (By[:] - By[:])*(bx/dz) 
            #Ax += (Bz[:] - Bz[:])*(bx/dy) 

            Ay -= (Bz[1:Nsz[0]] - Bz[0:Nsz[0]-1])*(by/dx) 
            #Ay += (Bx[:       ] - Bx[:         ])*(by/dz) 

            #Az -= (Bx[:       ] - Bx[:         ])*(bz/dy) 
            Az += (By[1:Nsy[0]] - By[0:Nsy[0]-1])*(bz/dx) 
        return [Ax, Ay, Az]


    def Update_adAdt_bB(self, A, B, C_list=None, a=None, b=None, c_list=None):
        """ a*d/dt A = b*B
            all are side/face elems
        """
        if a==None:
            a = np.ones(3)
        if b==None:
            b = np.ones(3)

        ax, ay, az = a
        bx, by, bz = b

        Ax, Ay, Az = A
        Bx, By, Bz = B
        
        dt = self.dt
        
        if C_list!=None:
            if c_list==None:
                c_list = [None]*len(C_list)
            for i in range(len(C_list)):
                C = C_list[i]
                c = c_list[i]
                if c==None:
                    c = np.ones(3)
                    
                Cx, Cy, Cz = C
                cx, cy, cz = c
                Ax += Cx*(cx*dt/ax)
                Ay += Cy*(cy*dt/ay)
                Az += Cz*(cz*dt/az)

        Ax += Bx*(bx*dt/ax)
        Ay += By*(by*dt/ay)
        Az += Bz*(bz*dt/az)
        

    def Update_aA_bB(self, A, B, C_list=None, a=None, b=None, c_list=None):
        """ a*A = b*B
            all are side/face elems
        """
        if a==None:
            a = np.ones(3)
        if b==None:
            b = np.ones(3)

        ax, ay, az = a
        bx, by, bz = b

        Bx, By, Bz = B
                
        A[0] = Bx*(bx/ax)
        A[1] = By*(by/ay)
        A[2] = Bz*(bz/az)

        Ax, Ay, Az = A

        if C_list!=None:
            if c_list==None:
                c_list = [None]*len(C_list)
            for i in range(len(C_list)):
                C = C_list[i]
                c = c_list[i]
                if c==None:
                    c = np.ones(3)
                    
                Cx, Cy, Cz = C
                cx, cy, cz = c
                Ax += Cx*(cx/ax)
                Ay += Cy*(cy/ay)
                Az += Cz*(cz/az)


    def ResetSideWalls(self, A):
        """ A is side element
        """
        Nsx, Nsy, Nsz = self.Nsx, self.Nsy, self.Nsz
        Ax, Ay, Az = A
        
        if self.n_dim==3:
            Ax[:       , 0       , :       ] = 0.0
            Ax[:       , Nsx[1]-1, :       ] = 0.0
            Ax[:       , :       , 0       ] = 0.0
            Ax[:       , :       , Nsx[2]-1] = 0.0
            
            Ay[0       , :       , :       ] = 0.0
            Ay[Nsy[0]-1, :       , :       ] = 0.0
            Ay[:       , :       , 0       ] = 0.0
            Ay[:       , :       , Nsy[2]-1] = 0.0

            Az[0       , :       , :       ] = 0.0
            Az[Nsz[0]-1, :       , :       ] = 0.0
            Az[:       , 0       , :       ] = 0.0
            Az[:       , Nsz[1]-1, :       ] = 0.0
        elif self.n_dim==2:
            Ax[:       , 0       ] = 0.0
            Ax[:       , Nsx[1]-1] = 0.0
            
            Ay[0       , :       ] = 0.0
            Ay[Nsy[0]-1, :       ] = 0.0

            Az[0       , :       ] = 0.0
            Az[Nsz[0]-1, :       ] = 0.0
            Az[:       , 0       ] = 0.0
            Az[:       , Nsz[1]-1] = 0.0
        elif self.n_dim==1:            
            Ay[0       ] = 0.0
            Ay[Nsy[0]-1] = 0.0

            Az[0       ] = 0.0
            Az[Nsz[0]-1] = 0.0


    def SetSpatialPointsSide(self):     
        if self.n_dim==3:   
            dx, dy, dz = self.dr[0], self.dr[1], self.dr[2]
            x0, y0, z0 = self.r0[0], self.r0[1], self.r0[2]
            x1, y1, z1 = self.r1[0], self.r1[1], self.r1[2]
            nx, ny, nz = self.N[0],  self.N[1],  self.N[2]
            
            x_1d = np.linspace(x0+dx/2, x1-dx/2, nx, endpoint=True)
            y_1d = np.linspace(y0+dy/2, y1-dy/2, ny, endpoint=True)
            z_1d = np.linspace(z0+dz/2, z1-dz/2, nz, endpoint=True)

            x_1dp = np.linspace(x0, x1, nx+1, endpoint=True)
            y_1dp = np.linspace(y0, y1, ny+1, endpoint=True)
            z_1dp = np.linspace(z0, z1, nz+1, endpoint=True)
             
            rx_x, rx_y, rx_z = np.meshgrid(x_1d, y_1dp, z_1dp, indexing='ij')
            self.rsx = [rx_x, rx_y, rx_z]

            ry_x, ry_y, ry_z = np.meshgrid(x_1dp, y_1d, z_1dp, indexing='ij')
            self.rsy = [ry_x, ry_y, ry_z]

            rz_x, rz_y, rz_z = np.meshgrid(x_1dp, y_1dp, z_1d, indexing='ij')
            self.rsz = [rz_x, rz_y, rz_z]
        elif self.n_dim==2:   
            dx, dy, dz = self.dr[0], self.dr[1], None
            x0, y0, z0 = self.r0[0], self.r0[1], None
            x1, y1, z1 = self.r1[0], self.r1[1], None
            nx, ny, nz = self.N[0],  self.N[1],  None
            
            x_1d = np.linspace(x0+dx/2, x1-dx/2, nx, endpoint=True)
            y_1d = np.linspace(y0+dy/2, y1-dy/2, ny, endpoint=True)

            x_1dp = np.linspace(x0, x1, nx+1, endpoint=True)
            y_1dp = np.linspace(y0, y1, ny+1, endpoint=True)
             
            rx_x, rx_y = np.meshgrid(x_1d, y_1dp, indexing='ij')
            self.rsx = [rx_x, rx_y]

            ry_x, ry_y = np.meshgrid(x_1dp, y_1d, indexing='ij')
            self.rsy = [ry_x, ry_y]

            rz_x, rz_y = np.meshgrid(x_1dp, y_1dp, indexing='ij')
            self.rsz = [rz_x, rz_y]
        elif self.n_dim==1:   
            dx, dy, dz = self.dr[0], None, None
            x0, y0, z0 = self.r0[0], None, None
            x1, y1, z1 = self.r1[0], None, None
            nx, ny, nz = self.N[0],  None,  None
            
            x_1d = np.linspace(x0+dx/2, x1-dx/2, nx, endpoint=True)

            x_1dp = np.linspace(x0, x1, nx+1, endpoint=True)
             
            rx_x = x_1d
            self.rsx = [rx_x]

            ry_x = x_1dp
            self.rsy = [ry_x]

            rz_x = x_1dp
            self.rsz = [rz_x]


    def SetSpatialPointsFace(self):        
        if self.n_dim==3:
            dx, dy, dz = self.dr[0], self.dr[1], self.dr[2]
            x0, y0, z0 = self.r0[0], self.r0[1], self.r0[2]
            x1, y1, z1 = self.r1[0], self.r1[1], self.r1[2]
            nx, ny, nz = self.N[0],  self.N[1],  self.N[2]
            
            x_1d = np.linspace(x0+dx/2, x1-dx/2, nx, endpoint=True)
            y_1d = np.linspace(y0+dy/2, y1-dy/2, ny, endpoint=True)
            z_1d = np.linspace(z0+dz/2, z1-dz/2, nz, endpoint=True)

            x_1dp = np.linspace(x0, x1, nx+1, endpoint=True)
            y_1dp = np.linspace(y0, y1, ny+1, endpoint=True)
            z_1dp = np.linspace(z0, z1, nz+1, endpoint=True)
            
            rx_x, rx_y, rx_z = np.meshgrid(x_1dp, y_1d, z_1d, indexing='ij')
            self.rfx = [rx_x, rx_y, rx_z]
             
            ry_x, ry_y, ry_z = np.meshgrid(x_1d, y_1dp, z_1d, indexing='ij')
            self.rfy = [ry_x, ry_y, ry_z]

            rz_x, rz_y, rz_z = np.meshgrid(x_1d, y_1d, z_1dp, indexing='ij')
            self.rfz = [rz_x, rz_y, rz_z]
        elif self.n_dim==2:
            dx, dy, dz = self.dr[0], self.dr[1], None
            x0, y0, z0 = self.r0[0], self.r0[1], None
            x1, y1, z1 = self.r1[0], self.r1[1], None
            nx, ny, nz = self.N[0],  self.N[1],  None
            
            x_1d = np.linspace(x0+dx/2, x1-dx/2, nx, endpoint=True)
            y_1d = np.linspace(y0+dy/2, y1-dy/2, ny, endpoint=True)

            x_1dp = np.linspace(x0, x1, nx+1, endpoint=True)
            y_1dp = np.linspace(y0, y1, ny+1, endpoint=True)
            
            rx_x, rx_y = np.meshgrid(x_1dp, y_1d, indexing='ij')
            self.rfx = [rx_x, rx_y]
             
            ry_x, ry_y = np.meshgrid(x_1d, y_1dp, indexing='ij')
            self.rfy = [ry_x, ry_y]

            rz_x, rz_y = np.meshgrid(x_1d, y_1d, indexing='ij')
            self.rfz = [rz_x, rz_y]
        elif self.n_dim==1:
            dx, dy, dz = self.dr[0], None, None
            x0, y0, z0 = self.r0[0], None, None
            x1, y1, z1 = self.r1[0], None, None
            nx, ny, nz = self.N[0],  None,  None
            
            x_1d = np.linspace(x0+dx/2, x1-dx/2, nx, endpoint=True)

            x_1dp = np.linspace(x0, x1, nx+1, endpoint=True)
            
            rx_x = x_1dp
            self.rfx = [rx_x]
             
            ry_x = x_1d
            self.rfy = [ry_x]

            rz_x = x_1d
            self.rfz = [rz_x]
    

    def UpdateFuncSide_space(self, A, f):
        fx, fy, fz = f
        rsx, rsy, rsz = self.rsx, self.rsy, self.rsz
        if self.n_dim==1:
            rsx, rsy, rsz = self.rsx[0], self.rsy[0], self.rsz[0]
        
        if fx!=None:                
            A[0] = fx(rsx)
        if fy!=None:                
            A[1] = fy(rsy)
        if fz!=None:                
            A[2] = fz(rsz)
        A_copy = [np.copy(A[0]), np.copy(A[1]), np.copy(A[2])]
        return A_copy
            

    def UpdateFuncSide_spacetime(self, A, f, t):
        fx, fy, fz = f
        rsx, rsy, rsz = self.rsx, self.rsy, self.rsz
        if self.n_dim==1:
            rsx, rsy, rsz = self.rsx[0], self.rsy[0], self.rsz[0]
        
        if fx!=None:                
            A[0] = fx(rsx, t)
        if fy!=None:                
            A[1] = fy(rsy, t)
        if fz!=None:                
            A[2] = fz(rsz, t)
        A_copy = [np.copy(A[0]), np.copy(A[1]), np.copy(A[2])]
        return A_copy

    
    def UpdateFuncFace_space(self, A, f):
        fx, fy, fz = f
        rfx, rfy, rfz = self.rfx, self.rfy, self.rfz
        if self.n_dim==1:
            rfx, rfy, rfz = self.rfx[0], self.rfy[0], self.rfz[0]

        if fx!=None:                
            A[0] = fx(rfx)
        if fy!=None:                
            A[1] = fy(rfy)
        if fz!=None:                
            A[2] = fz(rfz)
        A_copy = [np.copy(A[0]), np.copy(A[1]), np.copy(A[2])]
        return A_copy
        

    def UpdateFuncFace_spacetime(self, A, f, t):
        fx, fy, fz = f
        rfx, rfy, rfz = self.rfx, self.rfy, self.rfz
        if self.n_dim==1:
            rfx, rfy, rfz = self.rfx[0], self.rfy[0], self.rfz[0]

        if fx!=None:                
            A[0] = fx(rfx, t)
        if fy!=None:                
            A[1] = fy(rfy, t)
        if fz!=None:                
            A[2] = fz(rfz, t)
        A_copy = [np.copy(A[0]), np.copy(A[1]), np.copy(A[2])]
        return A_copy


    def UpdateSeperableFunc_Time(self, A, A_0, f, t):
        A[0] = f(t)*A_0[0]
        A[1] = f(t)*A_0[1]
        A[2] = f(t)*A_0[2]

        
    def ComplexEpsToEpsSigmaE(self, eps_c, omega):
        eps = np.real(eps_c)
        sig = -np.imag(eps_c)*omega
        return [eps, sig]


    def ComplexMuToMuSigmaM(self, mu_c, omega):
        mu = np.real(mu_c)
        sig = -np.imag(mu_c)*omega
        return [eps, sig]


    def GetWallsAllDic__ver_0(self, dw, s):
        if self.n_dim==3:
            dx, dy, dz = dw[0], dw[1], dw[2]
            sx, sy, sz = s
            walls = {('x', 'n'):[sx, dx], ('x', 'p'):[sx, dx],
                     ('y', 'n'):[sy, dy], ('y', 'p'):[sy, dy],
                     ('z', 'n'):[sz, dz], ('z', 'p'):[sz, dz]}
            return walls
        elif self.n_dim==2:
            dx, dy = dw[0], dw[1]
            sx, sy = s
            walls = {('x', 'n'):[sx, dx], ('x', 'p'):[sx, dx],
                     ('y', 'n'):[sy, dy], ('y', 'p'):[sy, dy]}
            return walls
        elif self.n_dim==1:
            dx = dw[0]
            sx = s
            walls = {('x', 'n'):[sx, dx], ('x', 'p'):[sx, dx]}
            return walls


    def GetWallsAllDic(self, dw, s):
        if self.n_dim==3:
            dx, dy, dz = dw[0], dw[1], dw[2]
            sx, sy, sz = s
            walls = {}
            if dx>0.0:
                walls[('x', 'n')] = [sx, dx]
                walls[('x', 'p')] = [sx, dx]
            if dy>0.0:
                walls[('y', 'n')] = [sy, dy]
                walls[('y', 'p')] = [sy, dy]
            if dz>0.0:
                walls[('z', 'n')] = [sz, dz]
                walls[('z', 'p')] = [sz, dz]
            return walls
        elif self.n_dim==2:
            dx, dy = dw[0], dw[1]
            sx, sy = s
            walls = {}
            if dx>0.0:
                walls[('x', 'n')] = [sx, dx]
                walls[('x', 'p')] = [sx, dx]
            if dy>0.0:
                walls[('y', 'n')] = [sy, dy]
                walls[('y', 'p')] = [sy, dy]
            return walls
        elif self.n_dim==1:
            dx = dw[0]
            sx = s
            walls = {}
            if dx>0.0:
                walls[('x', 'n')] = [sx, dx]
                walls[('x', 'p')] = [sx, dx]
            return walls

    def GetUPMLFactor(self, walls, eps_or_s='s', side_or_face='side'):
        """ walls:{('x', 'n'):[sx, dx], ('y', 'p'):[sy, dy]..}
            ('x', 'n'):[sx, dx] --> plane normal to x direction, negative side, 
                stretch factor sx, thickness dx
            eps_or_s='eps'/'s'
            returns boxes with complex upml permittivity/permeability factors
            if eps_or_s=='s' returns where sx/sy/sz are non-zero
        """
        Nx, Ny, Nz = [None]*3
        if side_or_face=='side':
            Nx, Ny, Nz = self.Nsx, self.Nsy, self.Nsz
        else:
            assert side_or_face=='face'
            Nx, Ny, Nz = self.Nfx, self.Nfy, self.Nfz
            
        if eps_or_s=='eps':
            eps_xx = np.ones(Nx)
            eps_yy = np.ones(Ny)
            eps_zz = np.ones(Nz)
            for wall_dir in walls:
                w, n_dir = wall_dir
                f = None
                if w=='x':
                    r1 = np.copy(self.r1)
                    sx, dx = walls[wall_dir]
                    if n_dir=='n':
                        r1[0] = self.r0[0] + dx
                        r0 = np.copy(self.r0)
                        f_xx = self.FunctionBox(r0, r1, a=1.0/sx, b=1.0)    
                        f_yy = self.FunctionBox(r0, r1, a=sx, b=1.0)    
                        f_zz = self.FunctionBox(r0, r1, a=sx, b=1.0)    
                        f = [f_xx, f_yy, f_zz]
                    else:
                        assert n_dir=='p'
                        r0 = np.copy(self.r0)
                        r0[0] = self.r1[0] - dx
                        f_xx = self.FunctionBox(r0, r1, a=1.0/sx, b=1.0)    
                        f_yy = self.FunctionBox(r0, r1, a=sx, b=1.0)    
                        f_zz = self.FunctionBox(r0, r1, a=sx, b=1.0)    
                        f = [f_xx, f_yy, f_zz]
                elif w=='y':
                    assert self.n_dim>=2
                    r1 = np.copy(self.r1)
                    sy, dy = walls[wall_dir]
                    if n_dir=='n':
                        r1[1] = self.r0[1] + dy
                        r0 = np.copy(self.r0)
                        f_xx = self.FunctionBox(r0, r1, a=sy, b=1.0)    
                        f_yy = self.FunctionBox(r0, r1, a=1.0/sy, b=1.0)    
                        f_zz = self.FunctionBox(r0, r1, a=sy, b=1.0)    
                        f = [f_xx, f_yy, f_zz]
                    else:
                        assert n_dir=='p'
                        r0 = np.copy(self.r0)
                        r0[1] = self.r1[1] - dy
                        f_xx = self.FunctionBox(r0, r1, a=sy, b=1.0)    
                        f_yy = self.FunctionBox(r0, r1, a=1.0/sy, b=1.0)    
                        f_zz = self.FunctionBox(r0, r1, a=sy, b=1.0)    
                        f = [f_xx, f_yy, f_zz]
                else:
                    assert w=='z'
                    assert self.n_dim==3
                    r1 = np.copy(self.r1)
                    sz, dz = walls[wall_dir]
                    if n_dir=='n':
                        r1[2] = self.r0[2] + dz
                        r0 = np.copy(self.r0)
                        f_xx = self.FunctionBox(r0, r1, a=sz, b=1.0)    
                        f_yy = self.FunctionBox(r0, r1, a=sz, b=1.0)    
                        f_zz = self.FunctionBox(r0, r1, a=1.0/sz, b=1.0)    
                        f = [f_xx, f_yy, f_zz]
                    else:
                        assert n_dir=='p'
                        r0 = np.copy(self.r0)
                        r0[2] = self.r1[2] - dz
                        f_xx = self.FunctionBox(r0, r1, a=sz, b=1.0)    
                        f_yy = self.FunctionBox(r0, r1, a=sz, b=1.0)    
                        f_zz = self.FunctionBox(r0, r1, a=1.0/sz, b=1.0)    
                        f = [f_xx, f_yy, f_zz]
                
                A = [None]*3
                if side_or_face=='side':
                    self.UpdateFuncSide_space(A, f)
                else:
                    self.UpdateFuncFace_space(A, f)
                eps_xx *= A[0]
                eps_yy *= A[1]
                eps_zz *= A[2]
            return [eps_xx, eps_yy, eps_zz]
        else:
            assert eps_or_s == 's'
            sx_arr, sy_arr, sz_arr = [None]*3, [None]*3, [None]*3
            sx_arr[0] = np.ones(Nx, dtype=complex)   ## s_x for sides x
            sx_arr[1] = np.ones(Ny, dtype=complex)   ## s_x for sides y
            sx_arr[2] = np.ones(Nz, dtype=complex)

            sy_arr[0] = np.ones(Nx, dtype=complex)   ## s_y for sides x
            sy_arr[1] = np.ones(Ny, dtype=complex)   ## s_y for sides y
            sy_arr[2] = np.ones(Nz, dtype=complex)

            sz_arr[0] = np.ones(Nx, dtype=complex)   ## s_z for sides x
            sz_arr[1] = np.ones(Ny, dtype=complex)   ## s_z for sides y
            sz_arr[2] = np.ones(Nz, dtype=complex)

            for wall_dir in walls:
                w, n_dir = wall_dir
                f = None
                if w=='x':
                    r1 = np.copy(self.r1)
                    sx, dx = walls[wall_dir]
                    if n_dir=='n':
                        r1[0] = self.r0[0] + dx
                        r0 = np.copy(self.r0)
                        f = self.FunctionBox(r0, r1, a=sx-1.0, b=0.0)    
                    else:
                        assert n_dir=='p'
                        r0 = np.copy(self.r0)
                        r0[0] = self.r1[0] - dx
                        f = self.FunctionBox(r0, r1, a=sx-1.0, b=0.0)    
                    A = [None]*3
                    if side_or_face=='side':
                        self.UpdateFuncSide_space(A, [f, f, f])
                    else:
                        self.UpdateFuncFace_space(A, [f, f, f])
                    sx_arr[0] += A[0]
                    sx_arr[1] += A[1]
                    sx_arr[2] += A[2]
                elif w=='y':
                    assert self.n_dim>=2
                    r1 = np.copy(self.r1)
                    sy, dy = walls[wall_dir]
                    if n_dir=='n':
                        r1[1] = self.r0[1] + dy
                        r0 = np.copy(self.r0)
                        f = self.FunctionBox(r0, r1, a=sy-1.0, b=0.0)    
                    else:
                        assert n_dir=='p'
                        r0 = np.copy(self.r0)
                        r0[1] = self.r1[1] - dy
                        f = self.FunctionBox(r0, r1, a=sy-1.0, b=0.0)    
                    A = [None]*3
                    if side_or_face=='side':
                        self.UpdateFuncSide_space(A, [f, f, f])
                    else:
                        self.UpdateFuncFace_space(A, [f, f, f])
                    sy_arr[0] += A[0]
                    sy_arr[1] += A[1]
                    sy_arr[2] += A[2]
                else:
                    assert w=='z'
                    assert self.n_dim==3
                    r1 = np.copy(self.r1)
                    sz, dz = walls[wall_dir]
                    if n_dir=='n':
                        r1[2] = self.r0[2] + dz
                        r0 = np.copy(self.r0)
                        f = self.FunctionBox(r0, r1, a=sz-1.0, b=0.0)    
                    else:
                        assert n_dir=='p'
                        r0 = np.copy(self.r0)
                        r0[2] = self.r1[2] - dz
                        f = self.FunctionBox(r0, r1, a=sz-1.0, b=0.0)    
                    A = [None]*3
                    if side_or_face=='side':
                        self.UpdateFuncSide_space(A, [f, f, f])
                    else:
                        self.UpdateFuncFace_space(A, [f, f, f])
                    sz_arr[0] += A[0]
                    sz_arr[1] += A[1]
                    sz_arr[2] += A[2]
            return [sx_arr, sy_arr, sz_arr]
                    


    def FunctionSphere(self, r0, rad, a, b=0.0):
        """ r0: center
            rad: radius
            a: amplitude on shpere
            b: amplitude outside sphere
        """
        if self.n_dim==3:
            x0, y0, z0 = r0[0], r0[1], r0[2]        
            def f(r):
                x, y, z = r
                R2 = (x-x0)**2 + (y-y0)**2 + (z-z0)**2
                isin = (R2 <= rad**2)
                isout = np.logical_not(isin)
                res = None
                if inspect.isfunction(a):
                    res = a(r)*isin
                else:
                    res = a*isin
                if inspect.isfunction(b):
                    res += b(r)*isout
                else:
                    res += b*isout
                return res
            return f
        if self.n_dim==2:
            x0, y0 = r0[0], r0[1]        
            def f(r):
                x, y = r
                R2 = (x-x0)**2 + (y-y0)**2
                isin = (R2 <= rad**2)
                isout = np.logical_not(isin)
                res = None
                if inspect.isfunction(a):
                    res = a(r)*isin
                else:
                    res = a*isin
                if inspect.isfunction(b):
                    res += b(r)*isout
                else:
                    res += b*isout
                return res
            return f
        if self.n_dim==1:
            x0 = r0[0]        
            def f(r):
                x = r   ##TODO: make consistent --> x=r[0]
                R2 = (x-x0)**2
                isin = (R2 <= rad**2)
                isout = np.logical_not(isin)
                res = None
                if inspect.isfunction(a):
                    res = a(r)*isin
                else:
                    res = a*isin
                if inspect.isfunction(b):
                    res += b(r)*isout
                else:
                    res += b*isout
                return res
            return f

    def FunctionBox(self, r0, r1, a, b=0.0):
        """ r0: lowe left corner
            r1: upper right corner
            a: amplitude
        """
        if self.n_dim==3:
            x0, y0, z0 = r0[0], r0[1], r0[2]        
            x1, y1, z1 = r1[0], r1[1], r1[2]        
            assert x0<x1 and y0<y1 and z0<z1
            def f(r, t=0):
                x, y, z = r
                isin = (x>=x0) & (x<=x1) & (y>=y0) & (y<=y1) & (z>=z0) & (z<=z1)
                isout = np.logical_not(isin)
                res = None
                if inspect.isfunction(a):
                    a_args = inspect.getargspec(a)[0]
                    if len(a_args)==2:
                        res = a(r, t)*isin
                    else:
                        assert len(a_args)==1
                        res = a(r)*isin
                else:
                    res = a*isin
                if inspect.isfunction(b):
                    b_args = inspect.getargspec(b)[0]
                    if len(b_args)==2:
                        res += b(r, t)*isout
                    else:
                        assert len(b_args)==1
                        res += b(r)*isout
                else:
                    res += b*isout
                return res
            return f
        elif self.n_dim==2:
            x0, y0 = r0[0], r0[1]        
            x1, y1 = r1[0], r1[1]        
            assert x0<x1 and y0<y1
            def f(r, t=0):
                x, y = r
                isin = (x>=x0) & (x<=x1) & (y>=y0) & (y<=y1)
                isout = np.logical_not(isin)
                res = None
                if inspect.isfunction(a):
                    a_args = inspect.getargspec(a)[0]
                    if len(a_args)==2:
                        res = a(r, t)*isin
                    else:
                        assert len(a_args)==1
                        res = a(r)*isin
                else:
                    res = a*isin
                if inspect.isfunction(b):
                    b_args = inspect.getargspec(b)[0]
                    if len(b_args)==2:
                        res += b(r, t)*isout
                    else:
                        assert len(b_args)==1
                        res += b(r)*isout
                else:
                    res += b*isout
                return res
            return f
        elif self.n_dim==1:
            x0 = r0[0]        
            x1 = r1[0]        
            assert x0<x1
            def f(r, t=0):
                x = r
                isin = (x>=x0) & (x<=x1)
                isout = np.logical_not(isin)
                res = None
                if inspect.isfunction(a):
                    a_args = inspect.getargspec(a)[0]
                    if len(a_args)==2:
                        res = a(r, t)*isin
                    else:
                        assert len(a_args)==1
                        res = a(r)*isin
                else:
                    res = a*isin
                if inspect.isfunction(b):
                    b_args = inspect.getargspec(b)[0]
                    if len(b_args)==2:
                        res += b(r, t)*isout
                    else:
                        assert len(b_args)==1
                        res += b(r)*isout
                else:
                    res += b*isout
                return res
            return f
        
            

    def GetPointSourceFunc(self, r_0, mag=1.0, src_dir='x', em_type='e'):
        if em_type=='e':
            i_xyz_min, r_xyz_min, d_xyz_min = self.FindClosestSides(r_0)
            f_je = None
            if src_dir=='x':
                i_j, r_j, d_j = i_xyz_min[0], r_xyz_min[0], d_xyz_min[0]

                f_jex = self.FunctionSphere(r_j, d_j/2.0, mag)
                f_jey = lambda r : 0.0
                f_jez = lambda r : 0.0
                f_je = [f_jex, f_jey, f_jez]
            elif src_dir=='y':
                i_j, r_j, d_j = i_xyz_min[1], r_xyz_min[1], d_xyz_min[1]

                f_jex = lambda r : 0.0
                f_jey = self.FunctionSphere(r_j, d_j/2.0, mag)
                f_jez = lambda r : 0.0
                f_je = [f_jex, f_jey, f_jez]
            elif src_dir=='z':
                i_j, r_j, d_j = i_xyz_min[2], r_xyz_min[2], d_xyz_min[2]

                f_jex = lambda r : 0.0
                f_jey = lambda r : 0.0
                f_jez = self.FunctionSphere(r_j, d_j/2.0, mag)
                f_je = [f_jex, f_jey, f_jez]
            else:
                raise ValueError()
            
            return f_je
        elif em_type=='m' or em_type=='h':
            i_xyz_min, r_xyz_min, d_xyz_min = self.FindClosestFaces(r_0)
            f_jm = None
            if src_dir=='x':
                i_j, r_j, d_j = i_xyz_min[0], r_xyz_min[0], d_xyz_min[0]

                f_jmx = self.FunctionSphere(r_j, d_j/2.0, mag)
                f_jmy = lambda r : 0.0
                f_jmz = lambda r : 0.0
                f_jm = [f_jmx, f_jmy, f_jmz]
            elif src_dir=='y':
                i_j, r_j, d_j = i_xyz_min[1], r_xyz_min[1], d_xyz_min[1]

                f_jmx = lambda r : 0.0
                f_jmy = self.FunctionSphere(r_j, d_j/2.0, mag)
                f_jmz = lambda r : 0.0
                f_jm = [f_jmx, f_jmy, f_jmz]
            elif src_dir=='z':
                i_j, r_j, d_j = i_xyz_min[2], r_xyz_min[2], d_xyz_min[2]

                f_jmx = lambda r : 0.0
                f_jmy = lambda r : 0.0
                f_jmz = self.FunctionSphere(r_j, d_j/2.0, mag)
                f_jm = [f_jmx, f_jmy, f_jmz]
            else:
                raise ValueError()

            return f_jm
        else:
            raise ValueError()


    def GetSheetSourceFunc(self, r_0, mag=1.0, src_dir='x', norm_dir='x', em_type='e'):
        assert src_dir in ['x', 'y', 'z']
        assert norm_dir in ['x', 'y', 'z']
        assert em_type in ['e', 'm', 'h']
        if em_type=='e':
            i_xyz_min, r_xyz_min, d_xyz_min = self.FindClosestSides(r_0)
            f_je = None
            if src_dir=='x':
                i_j, r_j, d_j = i_xyz_min[0], r_xyz_min[0], d_xyz_min[0]
                d_min = min(self.dr)

                r0 = np.copy(self.r0)
                r1 = np.copy(self.r1)
                if norm_dir=='x':
                    r0[0] = r_j[0]-d_min/3
                    r1[0] = r_j[0]+d_min/3
                elif norm_dir=='y':
                    assert self.n_dim>=2
                    r0[1] = r_j[1]-d_min/3
                    r1[1] = r_j[1]+d_min/3
                elif norm_dir=='z':
                    assert self.n_dim==3
                    r0[2] = r_j[2]-d_min/3
                    r1[2] = r_j[2]+d_min/3
                
                f_jex = self.FunctionBox(r0, r1, mag)
                f_jey = lambda r : 0.0
                f_jez = lambda r : 0.0
                f_je = [f_jex, f_jey, f_jez]
            elif src_dir=='y':
                i_j, r_j, d_j = i_xyz_min[1], r_xyz_min[1], d_xyz_min[1]
                d_min = min(self.dr)

                r0 = np.copy(self.r0)
                r1 = np.copy(self.r1)
                if norm_dir=='x':
                    r0[0] = r_j[0]-d_min/3
                    r1[0] = r_j[0]+d_min/3
                elif norm_dir=='y':
                    assert self.n_dim>=2
                    r0[1] = r_j[1]-d_min/3
                    r1[1] = r_j[1]+d_min/3
                elif norm_dir=='z':
                    assert self.n_dim==3
                    r0[2] = r_j[2]-d_min/3
                    r1[2] = r_j[2]+d_min/3
                

                f_jex = lambda r : 0.0
                f_jey = self.FunctionBox(r0, r1, mag)
                f_jez = lambda r : 0.0
                f_je = [f_jex, f_jey, f_jez]
            elif src_dir=='z':
                i_j, r_j, d_j = i_xyz_min[2], r_xyz_min[2], d_xyz_min[2]
                d_min = min(self.dr)

                r0 = np.copy(self.r0)
                r1 = np.copy(self.r1)
                if norm_dir=='x':
                    r0[0] = r_j[0]-d_min/3
                    r1[0] = r_j[0]+d_min/3
                elif norm_dir=='y':
                    assert self.n_dim>=2
                    r0[1] = r_j[1]-d_min/3
                    r1[1] = r_j[1]+d_min/3
                elif norm_dir=='z':
                    assert self.n_dim==3
                    r0[2] = r_j[2]-d_min/3
                    r1[2] = r_j[2]+d_min/3

                f_jex = lambda r : 0.0
                f_jey = lambda r : 0.0
                f_jez = self.FunctionBox(r0, r1, mag)
                f_je = [f_jex, f_jey, f_jez]
            else:
                raise ValueError()
            
            return f_je
        elif em_type=='m' or em_type=='h':
            i_xyz_min, r_xyz_min, d_xyz_min = self.FindClosestFaces(r_0)
            f_jm = None
            if src_dir=='x':
                i_j, r_j, d_j = i_xyz_min[0], r_xyz_min[0], d_xyz_min[0]
                d_min = min(self.dr)

                r0 = np.copy(self.r0)
                r1 = np.copy(self.r1)
                if norm_dir=='x':
                    r0[0] = r_j[0]-d_min/3
                    r1[0] = r_j[0]+d_min/3
                elif norm_dir=='y':
                    assert self.n_dim>=2
                    r0[1] = r_j[1]-d_min/3
                    r1[1] = r_j[1]+d_min/3
                elif norm_dir=='z':
                    assert self.n_dim==3
                    r0[2] = r_j[2]-d_min/3
                    r1[2] = r_j[2]+d_min/3

                f_jmx = self.FunctionBox(r0, r1, mag)
                f_jmy = lambda r : 0.0
                f_jmz = lambda r : 0.0
                f_jm = [f_jmx, f_jmy, f_jmz]
            elif src_dir=='y':
                i_j, r_j, d_j = i_xyz_min[1], r_xyz_min[1], d_xyz_min[1]
                d_min = min(self.dr)

                r0 = np.copy(self.r0)
                r1 = np.copy(self.r1)
                if norm_dir=='x':
                    r0[0] = r_j[0]-d_min/3
                    r1[0] = r_j[0]+d_min/3
                elif norm_dir=='y':
                    assert self.n_dim>=2
                    r0[1] = r_j[1]-d_min/3
                    r1[1] = r_j[1]+d_min/3
                elif norm_dir=='z':
                    assert self.n_dim==3
                    r0[2] = r_j[2]-d_min/3
                    r1[2] = r_j[2]+d_min/3
                
                f_jmx = lambda r : 0.0
                f_jmy = self.FunctionBox(r0, r1, mag)
                f_jmz = lambda r : 0.0
                f_jm = [f_jmx, f_jmy, f_jmz]
            elif src_dir=='z':
                i_j, r_j, d_j = i_xyz_min[2], r_xyz_min[2], d_xyz_min[2]
                d_min = min(self.dr)

                r0 = np.copy(self.r0)
                r1 = np.copy(self.r1)
                if norm_dir=='x':
                    r0[0] = r_j[0]-d_min/3
                    r1[0] = r_j[0]+d_min/3
                elif norm_dir=='y':
                    assert self.n_dim>=2
                    r0[1] = r_j[1]-d_min/3
                    r1[1] = r_j[1]+d_min/3
                elif norm_dir=='z':
                    assert self.n_dim==3
                    r0[2] = r_j[2]-d_min/3
                    r1[2] = r_j[2]+d_min/3

                f_jmx = lambda r : 0.0
                f_jmy = lambda r : 0.0
                f_jmz = self.FunctionBox(r0, r1, mag)
                f_jm = [f_jmx, f_jmy, f_jmz]
            else:
                raise ValueError()

            return f_jm
        else:
            raise ValueError()


            

    def FindClosestSides(self, r0):
        """ r0:point
        """
        drx2=None
        if self.n_dim==3:
            drx2 = (self.rsx[0]-r0[0])**2 + (self.rsx[1]-r0[1])**2 + (self.rsx[2]-r0[2])**2
        elif self.n_dim==2:
            drx2 = (self.rsx[0]-r0[0])**2 + (self.rsx[1]-r0[1])**2
        elif self.n_dim==1:
            drx2 = (self.rsx[0]-r0[0])**2
        inds_minx_F = np.argmin(drx2)
        inds_min_x = np.unravel_index(inds_minx_F, self.Nsx)
        x_min = np.array([self.rsx[i][inds_min_x] for i in range(self.n_dim)])
        dx_min = np.sqrt(np.min(drx2))
        print('inds_min_x:', inds_min_x, 'd:', dx_min)

        dry2 = None
        if self.n_dim==3:
            dry2 = (self.rsy[0]-r0[0])**2 + (self.rsy[1]-r0[1])**2 + (self.rsy[2]-r0[2])**2
        elif self.n_dim==2:
            dry2 = (self.rsy[0]-r0[0])**2 + (self.rsy[1]-r0[1])**2
        elif self.n_dim==1:
            dry2 = (self.rsy[0]-r0[0])**2
        inds_miny_F = np.argmin(dry2)
        inds_min_y = np.unravel_index(inds_miny_F, self.Nsy)
        y_min = np.array([self.rsy[i][inds_min_y] for  i in range(self.n_dim)])
        dy_min = np.sqrt(np.min(dry2))
        print('inds_min_y:', inds_min_y, 'd:', np.sqrt(np.min(dry2)))

        drz2 = None
        if self.n_dim==3:
            drz2 = (self.rsz[0]-r0[0])**2 + (self.rsz[1]-r0[1])**2 + (self.rsz[2]-r0[2])**2
        elif self.n_dim==2:
            drz2 = (self.rsz[0]-r0[0])**2 + (self.rsz[1]-r0[1])**2 
        elif self.n_dim==1:
            drz2 = (self.rsz[0]-r0[0])**2 
        inds_minz_F = np.argmin(drz2)
        inds_min_z = np.unravel_index(inds_minz_F, self.Nsz)
        z_min = np.array([self.rsz[i][inds_min_z] for i in range(self.n_dim)])
        dz_min = np.sqrt(np.min(drz2))
        print('inds_min_z:', inds_min_z, 'd:', np.sqrt(np.min(drz2)))
        
        return [inds_min_x, inds_min_y, inds_min_z], [x_min, y_min, z_min],\
            np.array([dx_min, dy_min, dz_min])


    def FindClosestFaces(self, r0):
        """ r0:point
        """
        drx2=None
        if self.n_dim==3:
            drx2 = (self.rfx[0]-r0[0])**2 + (self.rfx[1]-r0[1])**2 + (self.rfx[2]-r0[2])**2
        elif self.n_dim==2:
            drx2 = (self.rfx[0]-r0[0])**2 + (self.rfx[1]-r0[1])**2
        elif self.n_dim==1:
            drx2 = (self.rfx[0]-r0[0])**2
        inds_minx_F = np.argmin(drx2)
        inds_min_x = np.unravel_index(inds_minx_F, self.Nfx)
        x_min = np.array([self.rfx[i][inds_min_x] for i in range(self.n_dim)])
        dx_min = np.sqrt(np.min(drx2))
        print('inds_min_x:', inds_min_x, 'd:', dx_min)

        dry2 = None
        if self.n_dim==3:
            dry2 = (self.rfy[0]-r0[0])**2 + (self.rfy[1]-r0[1])**2 + (self.rfy[2]-r0[2])**2
        elif self.n_dim==2:
            dry2 = (self.rfy[0]-r0[0])**2 + (self.rfy[1]-r0[1])**2
        elif self.n_dim==1:
            dry2 = (self.rfy[0]-r0[0])**2
        inds_miny_F = np.argmin(dry2)
        inds_min_y = np.unravel_index(inds_miny_F, self.Nfy)
        y_min = np.array([self.rfy[i][inds_min_y] for  i in range(self.n_dim)])
        dy_min = np.sqrt(np.min(dry2))
        print('inds_min_y:', inds_min_y, 'd:', np.sqrt(np.min(dry2)))

        drz2 = None
        if self.n_dim==3:
            drz2 = (self.rfz[0]-r0[0])**2 + (self.rfz[1]-r0[1])**2 + (self.rfz[2]-r0[2])**2
        elif self.n_dim==2:
            drz2 = (self.rfz[0]-r0[0])**2 + (self.rfz[1]-r0[1])**2 
        elif self.n_dim==1:
            drz2 = (self.rfz[0]-r0[0])**2 
        inds_minz_F = np.argmin(drz2)
        inds_min_z = np.unravel_index(inds_minz_F, self.Nfz)
        z_min = np.array([self.rfz[i][inds_min_z] for i in range(self.n_dim)])
        dz_min = np.sqrt(np.min(drz2))
        print('inds_min_z:', inds_min_z, 'd:', np.sqrt(np.min(drz2)))
        
        return [inds_min_x, inds_min_y, inds_min_z], [x_min, y_min, z_min],\
            np.array([dx_min, dy_min, dz_min])


    def SetViewPlane_Side(self, r0, A_dir_list):
        """ 3 normal planes passing through r0 will be returned 
            A: the fields to output for example [{'A':self.Ex, 'A_dir:''x', 
            'O_dir':'y', 'v_out':v), ..]
            var_out: save output to this variable (a list) when demanded
        """
        inds = self.FindClosestSides(r0)[0]
        ind_x, ind_y, ind_z = inds
        
        Ax_r = [None]*self.n_dim
        ix_p = [None]*self.n_dim
        for n in range(self.n_dim):
            ix_p[n] = [Ellipsis]*self.n_dim    ##plane normal to n
            ix_p[n][n] = ind_x[n]
            Ax_r[n] = [self.rsx[i][ix_p[n]] for i in range(self.n_dim)]
        
        ix_all = [Ellipsis]*self.n_dim   
        Ax_r_all = self.rsx
        if self.n_dim==0:
            Ax_r_all = self.rsx[0]


        Ay_r = [None]*self.n_dim
        iy_p = [None]*self.n_dim
        for n in range(self.n_dim):
            iy_p[n] = [Ellipsis]*self.n_dim    ##plane normal to n
            iy_p[n][n] = ind_y[n]
            Ay_r[n] = [self.rsy[i][iy_p[n]] for i in range(self.n_dim)]
        
        iy_all = [Ellipsis]*self.n_dim   
        Ay_r_all = self.rsy
        if self.n_dim==0:
            Ay_r_all = self.rsy[0]


        Az_r = [None]*self.n_dim
        iz_p = [None]*self.n_dim
        for n in range(self.n_dim):
            iz_p[n] = [Ellipsis]*self.n_dim    ##plane normal to n
            iz_p[n][n] = ind_z[n]
            Az_r[n] = [self.rsz[i][iz_p[n]] for i in range(self.n_dim)]
        
        iz_all = [Ellipsis]*self.n_dim   
        Az_r_all = self.rsz
        if self.n_dim==0:
            Az_r_all = self.rsz[0]


        for view_dic in A_dir_list:
            A = view_dic['A']           ##field
            A_dir = view_dic['A_dir']   ##field direction
            O_dir = view_dic['O_dir']   ##output plane is normal to this direction
            v_out = view_dic['v_out']   ##output list
            
            if A_dir=='x':
                n_dir=0
                if O_dir=='x':
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':ix_p[0], 'r':Ax_r[0]})
                elif O_dir=='y':
                    assert self.n_dim>=2
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':ix_p[1], 'r':Ax_r[1]})
                elif O_dir=='z':
                    assert self.n_dim==3
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':ix_p[2], 'r':Ax_r[2]})
                elif O_dir==None:
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':ix_all, 'r':Ax_r_all})
                else:
                    raise ValueError()
            elif A_dir=='y':
                n_dir=1
                if O_dir=='x':
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':iy_p[0], 'r':Ay_r[0]})
                elif O_dir=='y':
                    assert self.n_dim>=2
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':iy_p[1], 'r':Ay_r[1]})
                elif O_dir=='z':
                    assert self.n_dim==3
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':iy_p[2], 'r':Ay_r[2]})
                elif O_dir==None:
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':iy_all, 'r':Ay_r_all})
                else:
                    raise ValueError()
            elif A_dir=='z':
                n_dir=2
                if O_dir=='x':
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':iz_p[0], 'r':Az_r[0]})
                elif O_dir=='y':
                    assert self.n_dim>=2
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':iz_p[1], 'r':Az_r[1]})
                elif O_dir=='z':
                    assert self.n_dim==3
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':iz_p[2], 'r':Az_r[2]})
                elif O_dir==None:
                    self.ViewPlanes.append( {'v_out':v_out, 'A':A, 'A_dir':n_dir, 'ind':iz_all, 'r':Az_r_all})
                else:
                    raise ValueError()
            else:
                raise NotImplementedError()
                    
    
    def SaveOutputs(self):
        for vp in self.ViewPlanes:
            v_out = vp['v_out']
            A = vp['A']
            n_dir = vp['A_dir']
            ind = vp['ind']
            r = vp['r']
            
            v_out.append(np.copy(A[n_dir][ind]))
        
    def GetOutputs(self):
        outs = []
        for vp in self.ViewPlanes:
            v_out = vp['v_out']
            A = vp['A']
            n_dir = vp['A_dir']
            ind = vp['ind']
            r = vp['r']
            
            outs.append([r, v_out])
        return outs
        
        


