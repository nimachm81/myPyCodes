## TransLine_sym.py
## Transmission line equations

__all__ = ["TL"]

from sympy import *


class TL:
    
    def __init__(self, lossless=False):
        self.omega=Symbol('\\omega', real=True)
        self.R=Symbol('R', real=True)
        self.L=Symbol('L', real=True)
        self.G=Symbol('G', real=True)
        self.C=Symbol('C', real=True)
        self.Z_0 = Symbol('Z_0')
        self.gamma = Symbol('\\gamma')
        self.alpha = Symbol('\\alpha', real=True)
        self.beta = Symbol('\\beta', real=True)
        if lossless:
            self.R = 0
            self.G = 0
            self.Z_0 = Symbol('Z_0', real=True)
        return
        
    def isLossless(self, lossless=True):
        if lossless:
            self.R = 0
            self.G = 0
            self.Z_0 = Symbol('Z_0', real=True)
        else:
            self.R=Symbol('R', real=True)
            self.G=Symbol('G', real=True)
            self.Z_0 = Symbol('Z_0')
        return    
        
    def propConst(self):
        return sqrt((self.R+I*self.omega*self.L)*(self.G+I*self.omega*self.C))
        
    def charImp(self):
        return sqrt((self.R+I*self.omega*self.L)/(self.G+I*self.omega*self.C))
        
    def reflection(self, Z_L):
        return (Z_L - self.Z_0)/(Z_L + self.Z_0)
        
    def transmission(self, Z_L):
        return 2*Z_L/(Z_L + self.Z_0)        
    
    def inputImp(self, Z_L, l):
        if self.R==0 and self.G==0:
            return self.Z_0*(Z_L + I*self.Z_0*tan(self.beta*l))/\
                (self.Z_0 + I*Z_L*tan(self.beta*l))
        else:
            return self.Z_0*(Z_L + self.Z_0*tanh(self.gamma*l))/\
                (self.Z_0 + Z_L*tanh(self.gamma*l))
        
        
        
        
        
